; MSX Compatible BIOS ver 0.13 project "Be myself"
; copyright(c) 2002 BouKiCHi
;
; [date]
; 2002/08/07 start...
; 2002/08/09 my birthday!! & playable game!
; 2002/08/13 added font,print infomation
;            key_in routine
; 2002/08/15 improved cartridge recognition.
; 2002/08/19 added DCOMPR(0020h) function.
;            a decrease wait sec.
; 2002/08/20 added a $fcc2-$fcc4 table initializer.(playable zanac) 
;            added a in_joy and in_trig function.
;            divided half. use "set.bat" to rename and merge 32kbyte.
; 2002/08/21 change project name.
; 2002/08/24 added 0072h INITGRP(Screen2) routine,005Fh CHGMOD routine.
;            0090h sound_init function.
; 2002/08/26 added set initial value to GRP???,MLT???
;            rewrited function the recognition of memory. 
;            added routine of the call H.STKE. 
;            fixed many routines.
; 2002/08/27 added sound test mode.
;            fixed syntax for zmac (a Z80 assembler of UNIX) 
;	     and other assembler.
;            fixed RDPRIM function.
; 2002/09/08 added WRSLT function.
;            added keyboard routines.
;            added joystick code to GTSTCK & GTTRIG. 
; 2002/09/10 fixed memory initializing routine.
;            added function of memory maintenance. 
; 2002/09/11 added print_error routine.
;            fixed ROM search routine and usage of EXPTBL.
; 2002/09/12 added clear memory from RG8SAV to RG23SA
;            fixed return from ENASLT with DI.
; 2002/09/16 added system font of second half
; 2002/09/18 added CHPUT routine.
;            rewritten function curs2de,de2curs.
; 2002/09/19 fixed keyboard stroke speed.
;	     added scroll routine.
;            fixed init_grp 
; 2002/09/22 fixed init_sc5
; 2002/09/23 routine of disk was added.
; 2002/09/25   ENASLT was rewrtten.
;            init_sc7 was added.
; 2002/09/26 the keyboard routines were fixed.
; 2002/10/02 init_sc5 was improved.
; 

;        title "MSX COMPATIBLE BIOS for emulators ver 0.13 by BouKiCHi"

;---------------------------------------------------
; define I/O and Hook
;

PRN_STAT        equ $90        ; Printer Status
VDP_RP          equ $98        ; VDP Read Port
VDP_STAT        equ $99        ; VDP Status & Latch Reset

PSL_STAT        equ $A8        ; Slot status
KBD_STAT        equ $A9        ; Keyboard status
GIO_REGS        equ $AA        ; General IO register
PPI_REGS        equ $AB        ; PPI register

PSG_REGS        equ $A0        ; PSG register number
PSG_DATA        equ $A1        ; PSG data
PSG_STAT        equ $A2        ; PSG status


MAP_REG1        equ $FC        ; RAM Mapper 0000h-3FFFh
MAP_REG2        equ $FD        ; RAM Mapper 4000h-7FFFh
MAP_REG3        equ $FE        ; RAM Mapper 8000h-BFFFh
MAP_REG4        equ $FF        ; RAM Mapper C000h-FFFFh

VDP_DATA        equ $98        ; VDP data store
VDP_ADDR        equ $99        ; VDP address
VDP_PALT        equ $9A        ; VDP palette latch
VDP_REGS        equ $9B        ; VDP register access

H_KEYI          equ $FD9A      ; keyboard interrupt hook
H_TIMI          equ $FD9F      ; timer interrupt hook
H_NMI           equ $FDD6      ; non maskable interrupt hook
H_STKE          equ $FEDA      ; Stack error.

STKTOP          equ $F674

EXP_TBL         equ $FCC1      ; second slot infomation table
SLT_TBL         equ $FCC5      ; table of primary slot

EXBRSA          equ $FAF8      ; position of SUB-ROM.

SSL_REGS        equ $FFFF      ; register of second slot.

;----------------------------------------------
; WORK MEMORY TABLE
GRPNAM          equ $F3C7      ; Screen2 Name
GRPCOL          equ $F3C9      ; Screen2 Color
GRPCGP          equ $F3CB      ; Screen2 CG pattern
GRPATR          equ $F3CD      ; Screen2 Attribute
GRPPAT          equ $F3CF      ; Screen2 Sprite pattern

TXTNAM          equ $F3B3
TXTCOL          equ $F3B5
TXTCGP          equ $F3B7
TXTATR          equ $F3B9
TXTPAT          equ $F3BB

T32NAM          equ $F3BD
T32COL          equ $F3BF
T32CGP          equ $F3C1
T32ATR          equ $F3C3
T32PAT          equ $F3C5


NAMBAS          equ $F922
CGPBAS          equ $F924
PATBAS          equ $F926
ATRBAS          equ $F928

MLTNAM          equ $F3D2      ; Screen3 Name
MLTCOL          equ $F3D4      ; Screen3 Color
MLTCGP          equ $F3D6      ; Screen3 CG pattern
MLTATR          equ $F3D8      ; Screen3 Attribute
MLTPAT          equ $F3DA      ; Screen3 Sprite pattern

CLIKSW          equ $F3DB      ; Key Click.

STATFL          equ $F3E7
RG0SAV          equ $F3DF
RG1SAV          equ $F3E0

RG8SAV          equ $FFE7

CLIKFL          equ $FBD9
OLDKEY          equ $FBDA
NEWKEY          equ $FBE5
KEYBUF          equ $FBF0

PUTPNT          equ $F3F8      ; pointer of keybuffer address
GETPNT          equ $F3FA      ; pointer of keybuffer address
LIMPNT          equ $FC17      ; pointer of keybuffer address

BOTTOM          equ $FC48
HIMEM           equ $FC4A

JIFFY           equ $FC9E      ; timer counter.
SCRMOD          equ $FCAF


FORCLR          equ $F3E9
BAKCLR          equ $F3EA
BDRCLR          equ $F3EB

PSG_DBG         equ $F3EC      ; this is test flag for debug..

CSRY            equ $F3DC      ; cursor position(Y axis)
CSRX            equ $F3DD      ; cursor position(X axis)

LINL40          equ $F3AE
LINL32          equ $F3AF
LINLEN          equ $F3B0      ; Line length.
CRTCNT          equ $F3B1      ; screen rows

LINWRK          equ $FC18      ; text buffer of 40 cols.

ESCCNT          equ $FCA7      ; ESC counter.

;------------------------
;for sound_mode

SMOD_TSTSND     equ $FAFE   ; [byte] store flag of sound test..
SMOD_REQNUM     equ $F305   ; [byte] store request number.
SMOD_OLDKEY     equ $F306   ; [byte] store oldkey.
SMOD_ROMSUM     equ $F307   ; [word] store checksum.
SMOD_MUSLST     equ $F309   ; [word] store address of music list.
SMOD_INIT       equ $F30B   ; [word] store address of initialization.
SMOD_PLAY       equ $F30D   ; [word] store address of play routine.

;-----------------
; memory for the debug-subroutine
;-----------------

DISPADDR        equ $E010   ; memory of dumping address.
LASTSTAC        equ $E000
SP_REGS         equ $E002 

;---------------------
; Jump Table
;---------------------

;start
Start 
        code
;0000h CHKRAM
chkram
        org     $0000
        di
        jp      soft_reset

;pointer of font.
        org     $0004
        dw      MSXFont

        org     $0006

rdvdpa  db      VDP_DATA ; port of Read  VDP
wrvdpa  db      VDP_DATA ; port of Write VDP

;0008h SYNCHR
synchr
        org     $0008
        ret

;000Ch RDSLT   read memory from any slot. 

        org     $000c
        jp      rdslt

chrgtb
        org     $0010
        ret

;0014h WRSLT  write memory to any slot.
        org     $0014
        jp      wrslt
        ret
;0018h OUTDO
        org     $0018
        jp      ch_put
;001Ch CALSLT Interslot call routine.
calslt
        org     $001c
        jp      cal_slt
        ret

;0020h DCOMPR compare HL,DE
dcompr  org     $0020
        jp      wordcomp
        ret

;0024h ENA_SLT Change of Slot

        org     $0024
        jp      enaslt

;0028h MATH-PACK
        org     $0028
        ret

;002D version ID and other.
romid
        org     $002d
; MSX version ID
        db      0 ; 0 .. msx1 ,1 .. msx2
        db      0 ; ??
        db      0 ; ??

;0030h CALLF Interslot Call routine(RST 30h version)
        org     $0030
        jp      call_lf

;0038h INT_38 interrupt routine (RST38,VBlank,Timer...) 
        org     $0038
        jp      int_start

;0038h INITIO Initialize I/O
        org     $003b
        ret

;0041h DISSCR Disable Screen 
        org     $0041
        jp      disscr
;0044h ENASCR Enable Screen
        org     $0044
        jp      enascr
;---------------
;vdp_routine
;---------------
;0047h WRTVDP
        org 	$0047
        jp	wrt_vdp
;004Ah RDVRM
	org	$004a
	jp	rd_vrm
;004Dh WRTVRM
        org	$004d
        jp      wrt_vrm


;0050h SETRD
        org     $0050
        jp      vdp_setrd

;0053h SETWRT  .. Set adress for the write VRAM.  
        org     $0053
        jp      vdp_setwrt

        org     $0056
        jp      vdp_fillmem
        org     $0059
        jp      vdp_ldirmv   ; VRAM -> Memory
        org     $005C
        jp      vdp_data_rep ; Memory -> VRAM

;005Fh Change VDP screen mode.
       org      $005f
       jp       chgmod
                
;0062h  CHGCLR
       org      $0062
       jp       chgclr
        

;0066h INT_NMI .. Non Maskable Interrupt.
        org     $0066
        jp      nmi_int

;0069h CLRSPR  .. Clear all sprites

        org     $0069
        ret

;0072h INITGRP initialize screen to graphics mode.

        org     $0072
        jp      init_grp

;007Eh  SETGRP
        org     $007E
        jp      set_grp

;0085h DOLINE Line
doline
        org     $0085
        ret
;0089h GRPPRT basic?
grpprt
        org     $0089
        ret

        org     $008a
        ret
;
;0090h GICINI initialize sound ic
        org     $0090
        jp      sound_init
        org     $0093
        jp      sound_out
        org     $0096
        jp      sound_stat

;009Ch CHSNS  .. check KeyBuffer

        org     $009c
        jp      ch_sns

;009Fh CHGET .. Get data from keyboard buffer.

        org     $009f
        jp      ch_get

;00A2h  CHPUT .. Put charactor data to display.

        org     $00a2
        jp      ch_put

;00C6h  POSIT .. Cursor moves.
	org     $00c6
	jp	curxy

;00D5h GTSTCK .. Get Joystick position status

        org     $00d5
        jp      in_joy

;00D8h GTTRIG .. Get trigger status

        org     $00d8
        jp      in_trig

;012Dh WRTVDP .. Write VDP register.. 

        org     $012d
        ret

;0131h VDPSTA .. Read VDP status.. 
;vdpsta
        org     $0131
        ret


;chgsnd
        org     $0135
        ret

;0138h RDSLTREG Read register of primary slot
;g_slotreg
        org     $0138
        jp      get_slotreg

;013Bh WRSLTREG Write register of primary slot
;s_slotreg
        org     $013B
        jp      set_slotreg
;013Eh RDVDP Read VDP status.
        org     $013E
        jp      vdp_stat_in

;setpag  org    $013d
;        ret

;0141h SNSMAT check key mathrics
;snsmat
        org     $0141
        jp      in_keyboard

;phydio
        org     $0144
        ret

;0145h RSTPLT
;rstplt
        org     $0145
        ret

;0149h RSTPLT?
;rstplt
        org     $0149
        ret

;getplt
        org     $014d
        ret

;0156h KILBUF Clear buffer of keyboard.
        org     $0156
        jp      kilbuf

;0159h CALBAS call basic interpreter
        org     $0159
        jp      call_basic_intr

;beep
        org     $017d
        ret

;prompt
        org     $0181
        ret

;newpad
        org     $01ad
        ret

;chgmdp
        org     $01b5
        ret

;knjprt
        org     $01bd
        ret

;redclk
        org     $01f5
        ret

;wrtclk
        org     $01f9
        ret

; -------------------
; start up (reset) code
; -------------------

        org     $0200
soft_reset
;for debug...
;        ex     (sp),hl
;        ld     (LASTSTAC),hl
;
;        ld     hl,$0000
;        add    hl,sp
;        ld     (SP_REGS),hl
;
;        ld     hl,$f300

; initialize other interface.
        ld      a,$82
        out     (PPI_REGS),a
        ld      a,$50
        out     (GIO_REGS),a

;memory bank initialize.

        xor     a,a
;        out    (MAP_REG1),a
        inc     a
        out     (MAP_REG2),a
        inc     a
        out     (MAP_REG3),a
        inc     a
        out     (MAP_REG4),a

; memory check and select slot to the memory.
; C = Primary,B = secondary.

        ld      bc,$0303
chk_wrt_ram               ; check RAM on page3.
        in      a,(PSL_STAT)
        and     a,$3F
        ld      e,a

        ld      a,c
        and     a,$03
        rrca
        rrca
        or      a,e     
        out     (PSL_STAT),a ; A = BBxxxxxx

        ld      a,(SSL_REGS)
        cpl
        and     a,$3F
        ld      e,a

        ld      a,b
        and     a,$03
        rrca
        rrca
        or      a,e
        ld      (SSL_REGS),a ; A = EExxxxxx 
        ld      e,a

        ld      a,$12
        ld      ($c010),a
        ld      a,($c010)
        cp      a,$12
        jr      nz,cant_wrt
        jp      ram_ok
cant_wrt
        dec     b
        jp      p,chk_wrt_ram
        ld      b,$03
        dec     c
        jp      p,chk_wrt_ram
        ld      de,str_memory_err
        jp      print_error

ram_ok
        ld      hl,SLT_TBL
        ld      b,0
        ld      c,a
        add     hl,bc

        ld      a,e
        ld      (hl),a ; expanding slot.

        and     a,$0C

        in      a,(PSL_STAT)
        and     a,$03
        or      a,$80
        ld      (EXP_TBL),a   ; location of MAIN-ROM.
        and     a,$80
        ld      (EXP_TBL+1),a
        ld      (EXP_TBL+2),a
        ld      (EXP_TBL+3),a
 
; you can write the memory.


;----------------------
;start UserInterface ...
;----------------------


        ld      hl,$f300
        ld      sp,hl        ; set stack -> $f300

        call    init_ram

        call    check_rom

;        in      a,(PSL_STAT)
;        ld      ($F000),a
;        call    p3_chk

        call    init_vdp

        xor     a,a
        ld      (PSG_DBG),a

        call    sound_init

        ei

        call    disp_info
        call    start_cartprog

;----------------------
;Start Cartridge
;----------------------

start_game
        in      a,(PSL_STAT)
        rrca
        rrca
        and     a,$03
        cp      a,$03
        jr      z,dont_chgscr
        ld      a,$01
        call    chgmod
dont_chgscr
        ld      hl,stack_error
        push	hl
        ld      a,($4000)
        cp      a,'A'
        jr      nz,p3_run
        ld	hl,($4002)	; Cartridge Start Address
        jr      prg_jumper
p3_run
        ld      hl,($8002)      ; Cartridge Start Address
prg_jumper
        jp	(hl)		; Running ...


;-------------------------------
; display infomation 
;-------------------------------
disp_info

; if press shift key then goto debug_mode
;
        ld      a,$06
        call    in_keyboard
        bit     0,a
        jp      z,debug_mode


; display program infomation

        ld      hl,str_proginfo   ; HL = string address
        call    prn_text

        
        ld      a,($4000)
        cp      a,'A'
        ret     z
        ld      a,($8000)
        cp      a,'A'
        ret     z

        ld      hl,str_nocart
        call    prn_text

        jp      hang_up_mode


;----------------------------
start_cartprog
; if can see cartridge then run the program in slot.
        ld      hl,str_thanks
        call    prn_text

        ld      hl,str_slot
        call    prn_text

        call    get_slotreg
        rrca
        rrca
        and     a,$03


        ld      d,$00
        ld      e,a
        push    de

        call    vout_hex8
        call    vout_hyphen

        pop     de
        ld      hl,SLT_TBL
        add     hl,de
        ld      a,(hl)
        rrca
        rrca
        and     a,$03
        call    vout_hex8

;for debug & check motion.

        call    check_sum

        ld      a,(SMOD_TSTSND)
        or      a,a
        jr      z,stst_skip

;for sound-mode.
;        ld      hl,str_canstst
;        call    prn_text

stst_skip
        ld      b,120      ; 2sec wait (1 = 1/60sec)
        call    wait_key07 ; wait routine

;for sound-mode.
;        bit     7,a
;        call    z,sound_mode

        bit     5,a
        jp      z,sh_keyboard
        bit     0,a
        jp      z,debug_mode
        bit     1,a
        jr      nz,skip_msg

; check press ctrl key, display secret infomation.

        ld      hl,str_secretmsg
        call    prn_text

skip_msg
        ld      hl,str_crlf
        call    prn_text

        ld      hl,str_run
        call    prn_text

        call    dbg_reg

        ld      b,60       ; 1sec
        call    wait_b

        ret

; ------
; BIOS Debug routines
; ------
; HL ... address of NEWKEY .
; 
sh_keyboard
        call    init_vdp
kbd_lp
        ld      a,1
        ld      (CSRX),a
        ld      (CSRY),a
        ld      hl,NEWKEY

        ld      b,10
kbd_byteread
        push    bc
        ld      a,(hl)
        inc     hl
        ld      b,8
kbd_shift
        rlca
        push    af
        jr      c,kbd_on
;Bit[n] = 0
        ld      a,'0'
        call    ch_put
        pop     af
        jr      kbd_lpchk
;Bit[n] = 1
kbd_on
        ld      a,'1'
        call    ch_put
        pop     af
kbd_lpchk
        djnz    kbd_shift
        pop     bc
        ld      a,$0d
        call    ch_put
        ld      a,$0a
        call    ch_put

        djnz    kbd_byteread

        jp      kbd_lp


sh_debug
        ex      (sp),hl
        ld      (LASTSTAC),hl

debug_mode
        ; implant return code into hook. 
        ld      a,$C9
        ld      (H_KEYI),a
        ld      (H_TIMI),a

        call    init_vdp

        ld      a,1
        ld      (CSRX),a
        ld      a,1
        ld      (CSRY),a

        ld      hl,$4000 ; this address is start of Page1  
        ld      (DISPADDR),hl 

        ld      ix,(LASTSTAC)
        call    vout_hex16

        ld      a,' '
        call    ch_put

        ld      ix,(SP_REGS)
        call    vout_hex16
loop_dump
        call    disp_dump
        call    dump_keywait
        jr      loop_dump


;-----------------
; dump_program sub-routines.
;-----------------

disp_dump

        ld      a,1
        ld      (CSRX),a
        ld      a,3
        ld      (CSRY),a

        ld      ix,(DISPADDR)
        ld      c,$10   ; RegC = rows

dump_lp

        push    bc
        call    vout_hex16
        pop     bc
        ld      a,':'
        call    ch_put
        ld      b,$10   ; RegB = cols
d16_lp
        ld      a,(ix)
        push    bc
        call    vout_hex8
        pop     bc
        inc     ix
        djnz    d16_lp

        dec     c
        jr      nz,dump_lp

        ret

;-------------------------
; Wait of KeyloopRoutine
dump_keywait

        ld      e,$02

        ld      a,($E008)
        ld      d,a 

        ld      a,$08
        call    in_keyboard

        cp      a,d
        jr      z,dumpkey_loop
        ; case of A != E008
        ld      ($E008),a
        ld      e,$10  ; 

dumpkey_loop
        halt
        ld      a,($E008)
        ld      d,a 

        ld      a,$08
        call    in_keyboard

        dec     e
        jr      z,skip_kchk
        cp      a,d
        jr      z,dumpkey_loop

skip_kchk
        push    af
        ld      a,$06
        call    in_keyboard
        bit     0,a
        jr      nz,norm
        ld      iy,$1000
        jr      bit_chk
norm
        ld      iy,$100
bit_chk
        pop     af

        bit     7,a
        jr      z,on_pagedown
        bit     6,a
        jr      z,on_down
        bit     5,a
        jr      z,on_up
        bit     4,a
        jr      z,on_pageup

        ld      ($E008),a

        ld      a,$07
        call    in_keyboard

        bit     1,a
        jr      z,on_start

        jp      dumpkey_loop

on_pagedown
        push    iy
        pop     bc
        jr      up_addr
on_pageup
        push    iy
        pop     bc
        jr      down_addr
on_down
        ld      bc,$10
        jr      up_addr
on_up
        ld      bc,$10
        jr      down_addr

up_addr
        ld      hl,($E010)
        add     hl,bc
        ld      ($E010),hl
        ret
down_addr
        ld      hl,($E010)
        and     a
        sbc     hl,bc
        ld      ($E010),hl
        ret

on_start
        jp      start_game


;--------------------
;initialize VDP routine
;--------------------

init_vdp
        in      a,(VDP_STAT) ; reset Latch 

        ld      bc,$0000  ; R#0
        call    wrt_vdp
        ld      bc,$7001  ; R#1
        call    wrt_vdp 
        ld      bc,$0002  ; R#2  
        call    wrt_vdp
        ld      bc,$8003  ; R#3
        call    wrt_vdp
        ld      bc,$0104  ; R#4  
        call    wrt_vdp

        call    clr_text40

        ld      a ,$00
        ld      hl,$0800
        ld      bc,$0800
        call    vdp_fillmem

        ld      a ,$F5
        ld      hl,$2000
        ld      bc,$0020
        call    vdp_fillmem



; PatGenTbl
;        76543210 76543210
;        00000100 00000000
;             04h      00h

        ld      bc,$F507  ; R#7
        call    wrt_vdp

        in      a,(VDP_STAT) ; reset Latch

        ld      hl,MSXFont

        ld      de,$800
        ld      bc,$1000
        call    vdp_data_rep


        ret

;------------------------
; Clear Text
clr_text40
        xor     a,a
        ld      bc,$0800
        ld      hl,$0000
        call    vdp_fillmem
        ld      a,1
        ld      (CSRY),a
        ld      (CSRX),a
        ret

;------------------------
; initialize RAM

init_ram
        
; workarea initialize.

        ld      a,$00
        ld      hl,$F380
        ld      (hl),a
        ld      de,$F381
        ld      bc,$C7D
	ldir

; implant return code into hook. 
        ld      a,$C9 ; ret code
        ld      hl,H_KEYI
        ld      (hl),a
        ld      de,H_KEYI+1
        ld      bc,$024D
        ldir

;Clear key matrix...
        ld      a,$FF 
        ld      hl,OLDKEY
        ld      (hl),a
        ld      de,OLDKEY+1
        ld      bc,21
        ldir

;Clear keybuf...
        ld      a,$00 
        ld      hl,KEYBUF
        ld      (hl),a
        ld      de,KEYBUF+1
        ld      bc,39
        ldir

        ld      a,$00 
        ld      hl,$FFE7 ; RG8SAV
        ld      (hl),a
        ld      de,$FFE7+1
        ld      bc,15
        ldir

;Set address to pointer.
        ld      hl,KEYBUF
        ld      (PUTPNT),hl
        ld      (GETPNT),hl

        ld      hl,$8000
        ld      (BOTTOM),hl  ; page 1 and 2 are ROM. 3 and 4 are RAM.  

        ld      hl,$F380
        ld      (HIMEM),hl   ;  the address of work rom >= HIMEM.

        ld      (STKTOP),hl   ;  the address of BASIC stack.

        ld      hl,disk_intr
        ld      a,$C3
        ld      (H_STKE),a
        ld      (H_STKE+1),hl

;Forward RDPRIM routine to RAM.
        ld      hl,m_rdprim
        ld      de,$F380

        ld      bc,m_prim_end-m_rdprim
        ldir

; screen 1 initial address.
        ld      hl,$1800
        ld      (T32NAM),hl
        ld      hl,$2000
        ld      (T32COL),hl
        ld      hl,$0000
        ld      (T32CGP),hl
        ld      hl,$1B00
        ld      (T32ATR),hl
        ld      hl,$3800
        ld      (T32PAT),hl

; screen 2 initial address.
        ld      hl,$1800
        ld      (GRPNAM),hl
        ld      hl,$2000
        ld      (GRPCOL),hl
        ld      hl,$0000
        ld      (GRPCGP),hl
        ld      hl,$1B00
        ld      (GRPATR),hl
        ld      hl,$3800
        ld      (GRPPAT),hl

; other settings.
        ld      a,37
        ld      (LINLEN),a
        ld      a,29
        ld      (LINL32),a
        ld      a,37
        ld      (LINL40),a
        ld      a,24
        ld      (CRTCNT),a

        ld      a,$04
        ld      (BDRCLR),a
        ld      (BAKCLR),a
        ld      a,$0F
        ld      (FORCLR),a

        ld      a,$20
        ld      (RG1SAV),a

        ld      a,$08
        ld      (RG8SAV),a


        ret

;----------------------
;Check SUB-ROM position.
chksubpos
        ld      b,$03
        ld      hl,$0000
loop_subpos
        ld      a,b
        push    bc
        call    rdslt
        pop     bc
        cp      a,'C'
        jr      z,chked_c
slt_wrong
        djnz    loop_subpos
        xor     a,a
        ld      (EXBRSA),a
        ret
chked_c
        inc     hl
        ld      a,b
        push    bc
        call    rdslt
        pop     bc
        cp      a,'D'
        jr      z,chked_d
        dec     hl
        jr      slt_wrong
chked_d
        ld      a,b
        ld      (EXBRSA),a
        ret

;------------------------
;
;display register
;
dbg_reg
        push    ix
        push    iy
        push    hl
        push    de
        push    bc
        push    af

        ld      iy,6

        ld      a,1
        ld      (CSRX),a
        ld      a,14
        ld      (CSRY),a

dbg_loop  ; loop until pop all stack.
        pop     ix
        call    prn_hex

        dec     iy

        push    iy
        pop     bc

        xor     a,a
        or      a,c

        jp      nz,dbg_loop
        pop     ix
        push    ix
        jp      prn_hex ; Print PC


;------------------------
prn_hex
;BC = Reg
        call    prn_reg
        call    vout_hex16

        ld      a,' '
        call    ch_put

        ret

;------------------------
prn_reg
;
        push    hl
        push    bc
        push    iy
        pop     bc

        ld      a,c
        add     a,a
        add     a,a
        ld      c,a
        
        ld      hl,reg_tbl
        add     hl,bc

        ld      b,3
reg_lp
        ld      a,(hl)
        inc     hl
        call    ch_put
        djnz    reg_lp

        pop     bc
        pop     hl
        ret

;------------------------
vout_hex16
; display word scale hex number.
;IX = number
;dest = BC,HL,AF
        ; RegB upper 4bit
        ld      hl,hex_tbl
        push    ix
        pop     bc

        ld      a,b
        rlca
        rlca
        rlca
        rlca
        and     a,$0F

        ld      b,0
        ld      c,a
        add     hl,bc
        ld      a,(hl)
        call    ch_put


        ; RegB lower 4bit
        ld      hl,hex_tbl
        push    ix
        pop     bc

        ld      a,b
        and     a,$0F

        ld      b,0
        ld      c,a
        add     hl,bc
        ld      a,(hl)
        call    ch_put

        ; RegC upper 4bit
        ld      hl,hex_tbl
        push    ix
        pop     bc

        ld      a,c
        rlca
        rlca
        rlca
        rlca
        and     a,$0F

        ld      b,0
        ld      c,a
        add     hl,bc
        ld      a,(hl)
        call    ch_put

        ; RegC lower 4bit
        ld      hl,hex_tbl
        push    ix
        pop     bc

        ld      a,c
        and     a,$0F

        ld      b,0
        ld      c,a
        add     hl,bc
        ld      a,(hl)
        call    ch_put

        ret

;------------------------
vout_hex8
; display byte scale hex number.
;A = number
;dest = BC,HL,AF
        push    af ; this stack is use to lower 4bits.

        ; RegA upper 4bit

        ld      hl,hex_tbl
        rlca
        rlca
        rlca
        rlca
        and     a,$0F

        ld      b,0
        ld      c,a
        add     hl,bc
        ld      a,(hl)
        call    ch_put

        pop     af

        ; RegA lower 4bit
        ld      hl,hex_tbl

        and     a,$0F

        ld      b,0
        ld      c,a
        add     hl,bc
        ld      a,(hl)
        call    ch_put

        ret

;------------------------------
vout_hyphen
        ld      a,'-'
        call    ch_put
        ret


;------------------------
; wait routine.
;CAUTION!!
; set always EI.
; B = counter of loop
wait_b
        halt
        djnz    wait_b
        ret

;------------------------
; wait routine.
;CAUTION!!
; set always EI.
; in .... B = counter of loop.
; out ... A = 7th key mathrics.
; dest .. RegC
wait_key07
        ld      c,$ff
wk07_lp
        halt
        ld      a,($FBEB)
        and     a,c
        ld      c,a
        djnz    wk07_lp
        ld      a,c
        ret

;------------------------
;prn_text
; HL = string

prn_text
prn_str_disp
        ld      a,(hl)
        or      a,a
        jp      z,nul_term
        call    ch_put
        inc     hl
        jr      prn_str_disp
nul_term
        ret

;---------------------------------------------
check_rom

        ld      b,$80

chk_rom_loop
        ld      h,$40
        ld      a,b
        push    bc
        call    enaslt
        pop     bc

        ld      a,($4000)
        cp      a,'A'
        jr      nz,chk_p3

        ld      a,($4003)
        cp      a,$40
        jr      c,chk_p3  ; A-$40 < 0
        cp      a,$80
        jr      nc,chk_p3 ; A-$80 >= 0
        jp      chk_rom_ok 
;
chk_p3
        ld      h,$80
        ld      a,b
        push    bc
        call    enaslt
        pop     bc
        
        ld      a,($8003)
        cp      a,$80
        jr      c,no_cart  ; A-$80 < 0
        cp      a,$C0
        jr      nc,no_cart ; A-$C0 >= 0
        jp      chk_rom_ok 
;
no_cart
        inc     b
        ld      a,b
        and     a,$7f
        cp      a,$10
        jr      nz,chk_rom_loop 

chk_rom_ng
        ld      h,$40
        ld      a,$80

        push    bc
        call    enaslt
        pop     bc

chk_rom_ok
        ret

;----------------------------------
p3_chk
        ld      a,($8000)
        cp      a,'A' 
        jp      z,page_set0

        ret

page_set0
        call    get_slotreg
        ld      c,a
        and     a,$3F         ; 00111111
        ld      b,a
        and     a,$03         ; 000000AA
        rrca
        rrca
        or      a,b           ; AABBBBAA
        out     (PSL_STAT),a

        ld      a,(SSL_REGS)
        cpl
        and     a,$F3         ; 11110011
        ld      d,a
        and     a,$03         ; 00000011
        rlca
        rlca
        or      a,d           
        ld      (SSL_REGS),a 

        ld      a,c
        and     a,$F3
        ld      c,a
        and     a,$03
        rlca
        rlca
        or      a,c
        out     (PSL_STAT),a
        ret


;-------------------------------------
;convert cursor to RegDE
;-------------------------------------
;out.. DE = VRAM address.
curs2de
        push    af
        push    bc
        push    hl

        ld      de,40    ; text40 
        ld      hl,$0000

        ld      a,(CSRY)
        cp      a,2
        jr      c,c2d_add_skip
        dec     a
        ld      b,a
c2d_add_lp
        add     hl,de
        djnz    c2d_add_lp
c2d_add_skip
        ld      a,(CSRX)
        cp      a,2
        jr      c,c2d_add_skip2
        dec     a
        ld      e,a
        add     hl,de

c2d_add_skip2

        ld      de,hl

        pop     hl
        pop     bc
        pop     af
        ret


;-----------------------------------
; RegDE to Cursor (CSRX,CSRY)
de2curs
        push    af
        push    bc
        push    de
        push    hl

        ; 256 - 16 = 240
        ex      de,hl
        ld      bc,40
        ld      de,$0000
        jr      under_chk
d2c_sub_lp
        and     a
        sbc     hl,bc
        inc     e
under_chk
        xor     a,a
        cp      a,h
        jr      nz,d2c_sub_lp
        ld      a,l
        cp      a,40
        jr      nc,d2c_sub_lp

        ld      a,e
        inc     a
        ld      (CSRY),a
        ld      a,l
        inc     a
        ld      (CSRX),a

        pop     hl
        pop     de
        pop     bc
        pop     af
        ret



;----------------------------------

m_rdprim
        out     (PSL_STAT),a
        ld      e,(hl)
        jr      m_wrprm1
m_wrprim
        out     (PSL_STAT),a
        ld      (hl),e
m_wrprm1
        ld      a,d
        out     (PSL_STAT),a
        ret
m_clprim
        out     (PSL_STAT),a
        ex      af,af'
        call    cl_jp
        ex      af,af'
        pop     af
        out     (PSL_STAT),a
        ex      af,af'
        ret
m_cl_jp
        jp      (ix)
m_prim_end
        nop

rdprim  equ     $F380
wrprim  equ     rdprim+(m_wrprim-m_rdprim)
clprim  equ     rdprim+(m_clprim-m_rdprim)
cl_jp   equ     rdprim+(m_cl_jp-m_rdprim)


;---------------------------
; sub-routine
;---------------------------
; 000Ch RDSLT
; in ..  A = slotID , HL = Address
rdslt
        push    hl
        push    af

        ld      a,h
        rlca
        rlca
        and     a,$03 ; address upper 2bit

        ld      l,a  ; L=shift number
        ld      b,a

        ld      a,$03
        call    rdsft
        cpl
        ld      e,a ; E= MASK
        ld      a,l ; A=shift#
        ld      b,a ; B=shift#
        pop     af
        and     a,$03
        call    rdsft
        ld      b,a ; B=shifted slot
        in      a,(PSL_STAT)
        ld      d,a  ; D=old psl
        and     a,e
        or      a,b  ; changed slot
        pop     hl

        call    rdprim
        ld      a,e
        ret

rdsft
        inc     b
        dec     b
        ret     z
rdsft_lp
        rlca
        rlca
        djnz    rdsft_lp
        ret

; 0014h WRSLT
; in ..  A = slotID , HL = Address
wrslt
        push    hl
        push    af

        ld      a,h
        rlca
        rlca
        and     a,$03      ; address upper 2bit

        ld      l,a        ; L=shift number
        ld      b,a

        ld      a,$03
        call    rdsft
        cpl
        ld      e,a        ; E= MASK
        ld      a,l        ; A=shift#
        ld      b,a        ; B=shift#
        pop     af
        and     a,$03
        call    rdsft
        ld      b,a        ; B=shifted slot
        in      a,(PSL_STAT)
        ld      d,a        ; D=old psl
        and     a,e
        or      a,b        ; changed slot
        pop     hl

        call    wrprim
        ret


;-------------------------------------
; 001Ch CALSLT(conditional function)
; in .. IYh(SlotNumber),(IX)
cal_slt
        jp      (ix)

;--------------------------------
; 0020h DCOMPR
; in .. hl,de= number
wordcomp
        ld      a,h
        cp      a,d
        ret     nz
        ld      a,l
        cp      a,e
        ret


;--------------------------------
; 0024h ENASLT
; in .. hl=Address,a=slotnumber
; A = FxxxEESS
; RegA detail 
; F = Flag of Extended slot.
; E = Extended slot#
; S = slot#
; Dest. AF,BC,DE,DI

enaslt

; A=(A >> 6)&0x3
        di
	push	hl

	ld      l,a 	; L = FxxxEEPP

	and     a,$03   ; A = 000000PP
	ld      b,a
	ld      a,$AB
psl_dup_lp
	add	a,$55
	dec	b
        jp      p,psl_dup_lp

	ld      d,a     ; D = PP PP PP PP

	ld  	a,h
	rlca
	rlca
	and	a,$03

	ld      h,a	; H = addess upper 2bit

	ld      b,a

	ld	a,$C0
page_msk_lp
	rlca
	rlca
	dec	b
        jp      p,page_msk_lp

	ld	e,a	; E = 00 00 11 00(Page mask)
	cpl
	ld	c,a	; C = 11 11 00 11(AND MASK)

	ld	a,d
	and	a,e
	ld	b,a     ; B = 00 00 PP 00

	ld	a,l
	and	a,a
	jp	p,chg_psl

;SSL-Change
	rrca
	rrca
	and	a,$03   ; A = 000000SS

	push	hl
	push	bc

	ld	b,a
	ld      a,$AB
ssl_dup_lp
	add	a,$55
	dec	b
        jp      p,ssl_dup_lp

	and	a,e
	ld	b,a	; B = 00 00 SS 00

	ld	a,d
	and	a,$C0
	ld      h,a

	in	a,(PSL_STAT)
	ld	l,a
	and	a,$C0
	or	a,h
	out	(PSL_STAT),a

	ld	a,(SSL_REGS)
	cpl
	and	a,c
	or	a,b    ; A = xx xx SS xx ( x = old value )
	ld	c,a
	ld	(SSL_REGS),a

	ld	a,l
	out	(PSL_STAT),a

	; (SLTTBL + PP) <- RegC

	ld	hl,SLT_TBL

        ld      a,d
        and     a,$03	; A = 000000PP

        add     a,l
        ld      l,a	; L = L + A

        ld      a,h
        adc     a,0
        ld      h,a	; H = H + Cy

	ld	a,c
	ld	(hl),a

	pop	bc
	pop	hl

chg_psl
	in      a,(PSL_STAT)
        and     a,c
        or      a,b
        out     (PSL_STAT),a

	pop	hl
        ret


;--------------------------------
; 0030h CALLLF
call_lf
        pop     hl ; Address of SlotInfo
        ld      a,(hl)
        inc     hl
        ld      e,(hl)
        inc     hl
        ld      d,(hl)
        inc     hl
        ex      de,hl
        push    de
        push    hl
        push    af
        call    enaslt
        pop     af
        pop     hl
        jp      (hl)


;--------------------------------
; 0050h SETRD
vdp_setrd

        di
        ld      a,l
        out     (VDP_ADDR),a
        ld      a,h
        and     a,$3f
        out     (VDP_ADDR),a
        ei
        ret

;--------------------------------
; 0053h SETWRT
; set VRAM Address
vdp_setwrt

        di
        ld      a,l
        out     (VDP_ADDR),a
        ld      a,h
        and     a,$3f
        or      a,$40
        out     (VDP_ADDR),a
        ei
        ret

;--------------------------------
;0056h fill VRAM
;HL = VRAM address, BC = length , A = data
vdp_fillmem
        push    af
        call    vdp_setwrt
lp_u001
        pop     af
        out     (VDP_DATA),a
        push    af

        dec     bc
        ld      a,c
        or      b
        jr      nz,lp_u001
        pop     af
        ret

;--------------------------------
wrt_vdp 
; 0047h WRTVDP
;in:B = VDP Data , C = Reg#
; dest af,b 
        push    hl
        di
        ld      a,b
        out     (VDP_ADDR),a
        ld      a,c
        or      a,$80
        out     (VDP_ADDR),a
        ei
        ld      a,c
        and     a,$3F
        sub     a,8
        jr      nc,rg8_sav
        ld      a,b
        ld      b,0
        ld      hl,RG0SAV
        add     hl,bc
        ld      (hl),a
        pop     hl
        ret

rg8_sav
        push    bc
        ld      c,a

        ld      a,b
        ld      b,0
        ld      hl,RG8SAV
        add     hl,bc
        ld      (hl),a
        pop     bc
        pop     hl
        ret




;--------------------------------
;004Ah Read VRAM
rd_vrm
        call    vdp_setrd
        ex      (sp),ix
        ex      (sp),ix
        in      a,(VDP_DATA)
        ret


;--------------------------------
;004Dh Write VRAM
wrt_vrm
        push    af
        call    vdp_setwrt
        ex      (sp),ix
        ex      (sp),ix
        pop     af
        out     (VDP_DATA),a
        ret

;--------------------------------
;in de bc 
;dest. af de bc 
vdp_ldirmv
	call	vdp_setrd
	ex	(sp),ix
	ex	(sp),ix
ldir_lp1
	in	a,(VDP_DATA)
	ld	(de),a
	inc	de
	dec	bc
	ld	a,c
	or	b
	jr	nz,ldir_lp1
	ret

;--------------------------------
vdp_reg1chk
        ld      a,(RG1SAV)
        rrca
        rrca
        ld      a,$08
        ret     nc
        ld      a,$20
        ret

;--------------------------------
;in hl de bc 
;dest. af de bc 
vdp_data_rep
        ex      de,hl
        call    vdp_setwrt
lp_vd_rep
        ld      a,(de)
        out     (VDP_DATA),a
        inc     de
        dec     bc
        ld      a,c
        or      b
        jr      nz,lp_vd_rep
        ret
;------------------------------
;Initialize VDP to screen 5.
init_sc5
        ld      a,$05
        ld      (SCRMOD),a

        in      a,(VDP_STAT)	; reset Latch

        call    chgclr

        ld      a,(RG0SAV)
        and     a,$F1		; MASK 11110001
        or      a,$06           ; M4,M3 = 1

        ld      b,a             ; B = R#0 data
        ld      c,0

        call    wrt_vdp		; write VDP R#0


        ld      a,(RG0SAV+1)
        and     a,$E7           ; MASK 11100111

        ld      b,a             ; B = R#1 data
        inc     c

        call    wrt_vdp         ; write VDP R#1

        ld      hl,$0000
        ld      (NAMBAS),hl
        ld      (CGPBAS),hl
        ld      hl,$7600
        ld      (ATRBAS),hl
        ld      hl,$7800
        ld      (PATBAS),hl

        ld      b,$1F           ; B = data
        ld      c,2
        call    wrt_vdp         ; write VDP R#2

        ld      a,(RG0SAV+3)
        ld      b,a             ; B = data
        ld      c,3
        call    wrt_vdp         ; write VDP R#3

        ld      a,(RG0SAV+4)
        ld      b,a             ; B = data
        ld      c,4
        call    wrt_vdp         ; write VDP R#4

        ld      b,$ef           ; B = data
        ld      c,5
        call    wrt_vdp         ; write VDP R#5

        ld      b,$0f           ; B = data
        inc     c
        call    wrt_vdp         ; write VDP R#6



        ld      b,$08           ; B = data
        ld      c,8
        call    wrt_vdp         ; write VDP R#8

        ld      b,$80           ; B = data
        ld      c,9
        call    wrt_vdp         ; write VDP R#9


        ld      b,0             ; B = data
        ld      c,10
        call    wrt_vdp         ; write VDP R#10
        ld      b,0             ; B = data
        inc     c
        call    wrt_vdp         ; write VDP R#11
        ld      b,0             ; B = data
        inc     c
        call    wrt_vdp         ; write VDP R#12
        ld      b,0             ; B = data
        inc     c
        call    wrt_vdp         ; write VDP R#13
        ld      b,1             ; B = data
        inc     c
        call    wrt_vdp         ; write VDP R#14
        ld      b,0             ; B = data
        inc     c
        call    wrt_vdp         ; write VDP R#15
        ld      b,$0F           ; B = data
        inc     c
        call    wrt_vdp         ; write VDP R#16
        ld      b,$2C           ; B = data
        inc     c
        call    wrt_vdp         ; write VDP R#17
        ld      b,$00           ; B = data
        inc     c
        call    wrt_vdp         ; write VDP R#18
        ld      b,$00           ; B = data
        inc     c
        call    wrt_vdp         ; write VDP R#19
        ld      b,$00           ; B = data
        inc     c
        call    wrt_vdp         ; write VDP R#20

        ld      b,$3B           ; B = data
        inc     c
        call    wrt_vdp         ; write VDP R#21
        ld      b,$05           ; B = data
        inc     c
        call    wrt_vdp         ; write VDP R#22


        call    enascr
        ret

;------------------------------
;Initialize VDP to screen 7.
init_sc7
        ld      a,$07
        ld      (SCRMOD),a

        in      a,(VDP_STAT)	; reset Latch

        call    chgclr

        ld      a,(RG0SAV)
        and     a,$F1		; MASK 11110001
        or      a,$0A           ; M4,M3 = 1

        ld      b,a             ; B = R#0 data
        ld      c,0

        call    wrt_vdp		; write VDP R#0


        ld      a,(RG0SAV+1)
        and     a,$E7           ; MASK 11100111

        ld      b,a             ; B = R#1 data
        inc     c

        call    wrt_vdp         ; write VDP R#1

        ld      hl,$0000
        ld      (NAMBAS),hl
        ld      (CGPBAS),hl
        ld      hl,$7600
        ld      (ATRBAS),hl
        ld      hl,$7800
        ld      (PATBAS),hl

        ld      b,$1F           ; B = data
        ld      c,2
        call    wrt_vdp         ; write VDP R#2

        ld      a,(RG0SAV+4)
        ld      b,a             ; B = data
        ld      c,4
        call    wrt_vdp         ; write VDP R#4

        ld      a,(RG0SAV+3)
        ld      b,a             ; B = data
        ld      c,3
        call    wrt_vdp         ; write VDP R#3


        ld      b,0             ; B = data
        ld      c,10
        call    wrt_vdp         ; write VDP R#10
        ld      b,0             ; B = data
        inc     c
        call    wrt_vdp         ; write VDP R#11
        ld      b,0             ; B = data
        inc     c
        call    wrt_vdp         ; write VDP R#12


        ld      b,$00           ; B = data
        ld      c,19
        call    wrt_vdp         ; write VDP R#19

        ld      b,$01           ; B = data
        ld      c,15
        call    wrt_vdp         ; write VDP R#15

        in      a,(VDP_STAT)	; reset Latch


        ld      b,$00           ; B = data
        ld      c,15
        call    wrt_vdp         ; write VDP R#15




        ld      b,$ef           ; B = data
        ld      c,5
        call    wrt_vdp         ; write VDP R#5
        ld      b,$0f           ; B = data
        inc     c
        call    wrt_vdp         ; write VDP R#6

        call    enascr
        ret


;--------------------------------
;0072h INIGRP
init_grp
        ld      a,$02
        ld      (SCRMOD),a

        in      a,(VDP_STAT)	; reset Latch

        call    chgclr

        ld      a,(RG0SAV)
        and     a,$F1		; MASK 11110001
        or      a,2             ; M3 = 1

        ld      b,a             ; B = R#0 data
        ld      c,0

        call    wrt_vdp		; write VDP R#0


        ld      a,(RG1SAV)
        and     a,$E7           ; MASK 11100111

        ld      b,a             ; B = R#1 data
        inc     c

        call    wrt_vdp		; write VDP R#1

        ld      hl,(GRPNAM)
        call    vdp_setwrt
        ld      b,3
        xor     a,a
ig_loop
        out     (VDP_DATA),a
        inc     a
        jr      nz,ig_loop
        djnz    ig_loop

        ld      hl,(GRPATR)
        ld      (ATRBAS),hl

        ld      hl,(GRPPAT)
        ld      (PATBAS),hl

        ld      hl,GRPNAM
        ld      de,$7F03
        call    set_grp
        call    enascr
        ret

; HL = Address of table
; B  = DATA , C = VDP R#
; DE = VDPDATA
set_grp
        push    ix
        ld      ix,shift_tbl
        ld      c,2       ; C = VDP R#

        xor     a,a       ; data=0
        call    adr_sft   ; R#2
        ld      a,d       ; data=D
        call    adr_sft   ; R#3
        ld      a,e       ; data=E
        call    adr_sft   ; R#4
        xor     a,a       ; data=0
        call    adr_sft   ; R#5
        xor     a,a       ; data=0
        call    adr_sft
        pop     ix
        ret

shift_tbl
        db      $06,$0A,$05,$09,$05

;
;HL = Table Address
;
adr_sft
        push    hl
        push    af
        ld      b,(ix)
        inc     ix

	; HL <- (HL)
        ld      a,(hl)
        inc     hl
        ld      h,(hl)
        ld      l,a
sft_lp
        add     hl,hl
        adc     a,a
        djnz    sft_lp
        ld      h,a    ; H = shifted higher bit of HL
        pop     af     ; A = make up the deficit data.

        or      a,h
        ld      b,a

        call    wrt_vdp
        pop     hl
        inc     hl
        inc     hl
        inc     c
        ret

;----------------------------------
;005Fh CHGMOD   Change Screen mode
chgmod
        or      a,a
        jp      z,init_text  ; screen 0
        dec     a
        jp      z,init_txt32 ; screen 1
        dec     a
        jp      z,init_grp   ; screen 2
        dec     a
;
;        jp     z,init_mlt   ; screen 3
;
        dec     a
;
;        jp     z,init_sc4   ; screen 4
;
        dec     a
        jp      z,init_sc5   ; screen 5
        dec     a
;        jp      z,init_sc6  ; screen 6
        dec     a
        jp      z,init_sc7   ; screen 7

        ret

init_text
        ld      a,$00
        ld      (SCRMOD),a

        call    clr_text40

        in      a,(VDP_STAT)	; reset Latch
        call    chgclr

        ld      a,(RG0SAV)
        and     a,$F1		; MASK 11110001

        ld      b,a             ; B = R#0 data
        ld      c,0

        call    wrt_vdp		; write VDP R#0


        ld      a,(RG1SAV)
        and     a,$E7           ; MASK 11100111
        or      a,$10

        ld      b,a             ; B = R#1 data
        inc     c

        call    wrt_vdp		; write VDP R#1

        ret

;????h INITTXT32
init_txt32
        ; screen 1
        ld      a,$01
        ld      (SCRMOD),a

        call    clr_text40

        in      a,(VDP_STAT)	; reset Latch

        call    chgclr

        ld      a,(RG0SAV)
        and     a,$F1		; MASK 11110001

        ld      b,a             ; B = R#0 data
        ld      c,0

        call    wrt_vdp		; write VDP R#0


        ld      a,(RG1SAV)
        and     a,$E7           ; MASK 11100111

        ld      b,a             ; B = R#1 data
        inc     c

        call    wrt_vdp		; write VDP R#1

        ld     hl,(T32NAM)
        ld     (NAMBAS),hl
        ld     hl,(T32CGP)
        ld     (CGPBAS),hl
        ld     hl,(T32PAT)
        ld     (PATBAS),hl
        ld     hl,(T32ATR)
        ld     (ATRBAS),hl

        ld      hl,(T32NAM)
        ld      a,h
        rrca
        rrca
        and     a,$3F

        ld      b,a
        ld      c,2
        call    wrt_vdp         ; write VDP R#2


        ld     hl,(T32COL)
        ld     b,2
tcol_lp
        xor    a,a
        rl     l
        rl     h
        djnz   tcol_lp
        ld     a,h

        ld     b,a
        ld     c,3
        call    wrt_vdp         ; write VDP R#3

        ld      hl,(T32CGP)
        ld      a,h
        rrca
        rrca
        rrca
        and     a,$1F

        ld      b,a
        ld      c,4
        call    wrt_vdp         ; write VDP R#4

        ld      hl,(T32ATR)
        rl     l
        rl     h
        ld     a,h

        ld     b,a
        ld     c,5
        call   wrt_vdp         ; write VDP R#5
        
        ld      hl,(T32PAT)
        ld    a,h
        rrca
        rrca
        rrca
        and     a,$1F
        ld     b,a
        ld     c,6
        call   wrt_vdp         ; write VDP R#6




        ret

;0062h CHGCLR
;in = none
chgclr
        ld      a,(SCRMOD)
        dec     a
        push    af
        ld      a,(FORCLR)
        rlca
        rlca
        rlca
        rlca
        ld      l,a
        ld      a,(BDRCLR)
        or      a,l

        ld      b,a
        ld      c,7
        call    wrt_vdp
        pop     af
        ret     nz

        ld      a,(FORCLR)
        rlca
        rlca
        rlca
        rlca
        and     a,$F0
        ld      hl,BAKCLR
        or      a,(hl)
        ld      hl,(T32COL)
        ld      bc,$0020
        push    af
        call    vdp_setwrt
cclr_lp pop     af
        out     (VDP_DATA),a
        push    af
        dec     bc
        ld      a,b
        or      c
        jr      nz,cclr_lp
        pop     af
        ret

;0044h ENASCR
enascr
        in      a,(VDP_STAT) ; reset Latch

        ld      a,(RG1SAV)
        or      a,$40
        ld      b,a
        ld      c,1
        call    wrt_vdp
        ret

;00?? DISSCR
disscr
        in      a,(VDP_STAT) ; reset Latch

        ld      a,(RG1SAV)
        and     a,$BF
        ld      b,a
        ld      c,1
        call    wrt_vdp
        ret


;--------------------------------
;009Ch  CHSNS
ch_sns
        push    hl
        push    de
        ld      hl,(GETPNT)
        ld      de,(PUTPNT)
        call    wordcomp
        jr      z,no_chr
        ld      a,(hl)
        and     a,a
        pop     de
        pop     hl
        ret
no_chr
        xor     a,a
        and     a,a
        pop     de
        pop     hl
        ret

;---------------------------------
;009Fh  CHGET
ch_get
        ld      a,$00
        push    hl
        push    de
        push    bc
loop_chget
        ld      hl,(GETPNT)
        ld      de,(PUTPNT)
        call    wordcomp
        jr      nz,get_ch
        ei
        halt
        jr      loop_chget
get_ch
        ld      hl,(PUTPNT)
        ld      bc,(GETPNT)
        ld      a,(bc)
        and     a,a
        push    af
        ld      bc,39
        ld      hl,(GETPNT)
        inc     hl
        ld      de,(GETPNT)
        ldir
        ld      de,(PUTPNT)
        dec     de
        ld      (PUTPNT),de
        pop     af
        pop     bc
        pop     de
        pop     hl
        ret
;-----------------------------------
;00A2h  CHPUT
;in ... A = charactor code.
ch_put
        push    de
        push    af
        ld      a,(SCRMOD)
        ld      e,a
        ld      a,1
        cp      a,e
        jr      nc,scr_txt_mode
        pop     af
        pop     de
	ret
back_spc
        ld      a,(CSRX)
        cp      a,2
        jr      c,skip_bs
        dec     a
        ld      (CSRX),a
        call    set_curs
        xor     a,a
        out     (VDP_DATA),a
skip_bs
        pop     af
        pop     de
	ret
; 0Dh CR
ctrl_cr
        ld      a,1
        ld      (CSRX),a
        pop     af
        pop     de
	ret

; 0Ah LF  line feed
ctrl_lf
        ld      a,(CRTCNT)
        ld      e,a
        ld      a,(CSRY)
        cp      a,e
        jr      nc,lf_scroll
        inc     a
        ld      (CSRY),a
        pop     af
        pop     de
	ret
lf_scroll
	; scroll routine
        push    hl
        push    bc
        ld      hl,(NAMBAS)
        ld      de,LINWRK
        ld      a,(CRTCNT)
        ld      (CSRY),a
        dec     a
        ld      b,a

scr_loop
        push    bc

        ld      bc,40
        add     hl,bc

        push    hl
        push    de
        call    vdp_ldirmv  ; HL=VRAM,DE=RAM,BC=LENGTH
        pop     de
        pop     hl

        ld      bc,$FFD8   ; -40
        add     hl,bc

        ex      de,hl      ; DE = VRAM,HL = RAM

        ld      bc,40
        push    hl
        push    de
        call    vdp_data_rep
        pop     de
        pop     hl

        ex      de,hl      ; DE = RAM,HL = VRAM

        ld      bc,40      ; 80
        add     hl,bc
        pop     bc

        djnz    scr_loop

        ld      bc,40
        ld      a,0
        call    vdp_fillmem

        pop     bc
        pop     hl
        pop     af
        pop     de
	ret

scr_txt_mode
        pop     af
        push    af

	; CTRL code
        cp      a,$08
        jp      z,back_spc
        cp      a,$0d
        jp      z,ctrl_cr
        cp      a,$0a
        jp      z,ctrl_lf

	; Charactor code

        call    set_curs
        pop     af
        push    af
        out     (VDP_DATA),a
        ld      a,(LINLEN)
        ld      e,a
        ld      a,(CSRX)
        cp      a,e
        jr      nc,next_ptr

	; next point
        inc     a
        ld      (CSRX),a
        pop     af
        pop     de
	ret

next_ptr
        ld      a,1
        ld      (CSRX),a
        ld      a,(CSRY)
        inc     a
        ld      (CSRY),a
        pop     af
        pop     de
	ret

set_curs
        call    curs2de
        ex      de,hl
        call    vdp_setwrt
        ex      de,hl
	ret


;-----------------------
;00C6h	Cursor set to point.
;in ... RegH = X, RegL = Y
curxy
        ld      a,h
        ld      (CSRY),a
        ld      a,l
        ld      (CSRX),a
        ret

;-----------------------



;--------------------------------------
;0156h KILBUF clear buffer of keyboard.
kilbuf
        push    de
        push    bc
        push    af
        ld      hl,KEYBUF
        ld      (PUTPNT),hl

        ld      a,$FF
        ld      hl,OLDKEY
        ld      (hl),a
        ld      de,OLDKEY+1
        ld      bc,21
        ldir
        pop     af
        pop     bc
        pop     de
        ret


;--------------------------------
;0090h GICINIT initialize sound ic
sound_init
        ld      e,$00
        ld      a,$08
        call    sound_out
        inc     a
        call    sound_out
        inc     a   
        call    sound_out
        inc     a

        ld      e,$b8
        ld      a,$07
        call    sound_out
        ret

;--------------------------------
;0093h in a=reg#,e=data
sound_out
        di
        out     (PSG_REGS),a
        push    af
        ld      a,e
        out     (PSG_DATA),a
        ei
        pop     af

; for SOUND-MODE
;        push  af
;        push  de
;        ld    d,a
;        ld    a,(PSG_DBG)
;        or    a,a
;        call  nz,disp_psg
;        pop   de
;        pop   af

        ret

;--------------------------------
sound_stat
        out     (PSG_REGS),a
        in      a,(PSG_STAT)
        ret

;--------------------------------
get_slotreg
        in      a,(PSL_STAT)
        ret

;--------------------------------
set_slotreg
        out     (PSL_STAT),a
        ret

;--------------------------------
; 013Eh 
vdp_stat_in
        in      a,(VDP_STAT)
        ret

;--------------------------------
;0141h SNSMAT
; in a = Keyboard row number.
;dest AF,C,EI

in_keyboard
        di
        ld      c,a
        in      a,(GIO_REGS)
        and     a,$F0
        or      a,c
        out     (GIO_REGS),a
        in      a,(KBD_STAT)
        ei
        ret

;--------------------------------
;00D5h GTSTCK
; a = InID...
; dest AF,BC,EI
in_joy

        push    bc
        cp      a,$00
        jr      nz,joy_stc1

        ld      a,$08
        call    in_keyboard
        rrca
        rrca
        rrca
        rrca
        cpl
        and     a,$0f ; 0000RDUL
       
        push    hl
        ld      hl,joypos_kbd_tbl
        ld      b,0
        ld      c,a
        add     hl,bc
        ld      a,(hl)
        pop     hl
        pop     bc
        and     a,a
        ret
joy_stc1
;PSG reg 15h
;0J001111
;PSG reg 14h
;00BARLDU
        push    hl
        push    de

        ld      e,0
        dec     a
        jr      z,sel_stc1
        ld      a,$40
        ld      e,a
sel_stc1
        ld      a,$0F
        di
        call    sound_stat
        ei
        and     a,$BF
        or      a,e
        ld      e,a
        ld      a,$0F
        call    sound_out
        ld      a,$0e
        di
        call    sound_stat
        ei
        cpl
        and     a,$0f ; 0000RLDU
        

        ld      hl,joypos_joy_tbl
        ld      b,0
        ld      c,a
        add     hl,bc
        ld      a,(hl)
        pop     de
        pop     hl

        pop     bc
        and     a,a
        ret

joy_end
        ld      a,$00
        pop     bc
        and     a,a
        ret

joypos_joy_tbl
        ;    0   1   2   3   4   5   6   7
        db $00,$01,$05,$00,$07,$08,$06,$00
        ;    8   9   A   B   C   D   E   F
        db $03,$02,$04,$00,$00,$00,$00,$00

joypos_kbd_tbl
        ;    0   1   2   3   4   5   6   7
        db $00,$07,$01,$08,$05,$06,$00,$00
        ;    8   9   A   B   C   D   E   F
        db $03,$00,$02,$00,$04,$00,$00,$00


;--------------------------------
;00D8h GTTRIG
;dest AF,BC,EI
;

in_trig
        cp      a,$00
        jr      z,kbd_spc
        jr      joy_trig
kbd_spc
        ld      a,$08
        call    in_keyboard
        and     a,$01
        jr      z,spc_on
        jr      spc_off
spc_on
        ld      a,$FF
        ret
spc_off
        xor     a,a
        ret

joy_trig
        di
        dec     a
        push    de
        ld      e,$00
        ld      b,a
        and     a,$01
        jr      z,sel_trig1
        ld      e,$40
sel_trig1
        ld      a,$0F
        call    sound_stat
        and     a,$BF
        or      a,e
        ld      e,a
        ld      a,$0F
        call    sound_out

        ld      a,b
        ld      b,$10
        and     a,$02
        jr      z,istrg_a
        ld      b,$20
istrg_a
        ld      a,$0e
        di
        call    sound_stat
        ei
        pop     de
        and     a,b
        jr      z,trig_on
        jr      trig_off
trig_on
        ld      a,$FF
        ret
trig_off
        xor     a,a
        ret




;------------------
; interrupt routine code
;------------------

int_start
; for debug...
;        push    hl
;        ld  hl,$3232
;        ex (sp),hl
; 
        push    hl
        push    de
        push    bc
        push    af
        exx  
        ex      af,af'
        push    hl
        push    de
        push    bc
        push    af
        push    iy
        push    ix

        call    H_KEYI
        in      a,(VDP_STAT)
        or      a,a
        jp      p,int_end

        call    H_TIMI

        ld      hl,(JIFFY)
        inc     hl
        ld      (JIFFY),hl

        
        ei
        ld      (STATFL),a ; save status

        xor     a,a
        ld      (CLIKFL),a
        call    in_trig
        cpl
        and     a,$01
        ld      ($F3E8),a
        call    old_key
        call    key_in

int_end
        pop     ix
        pop     iy
        pop     af
        pop     bc
        pop     de
        pop     hl
        exx
        ex      af,af'
        pop     af
        pop     bc
        pop     de
        pop     hl
        ei
        ret

;--------------------------------
; 0066h NMI Interrupt
nmi_int
        call    H_NMI
        retn

;--------------------------------
old_key
        ld      de,NEWKEY
        ld      hl,OLDKEY
        ld      b,$0b
oldkey_lp
        ld      a,(de)
        ld      (hl),a
        inc     de
        inc     hl
        djnz    oldkey_lp
        ret

;--------------------------------
; input form keyboard to buffer.
key_in
        in      a,(GIO_REGS)
        and     a,$F0
        ld      c,a
        ld      b,$0b
        ld      hl,NEWKEY
key_in_lp
        ld      a,c
        out     (GIO_REGS),a
        in      a,(KBD_STAT)
        ld      (hl),a
        inc     hl
        inc     c
        djnz    key_in_lp
        call    key_chk
        ret

;--------------------------------
; key code check routine
; call from interrupt
;
key_chk
        ld      ix,OLDKEY
        ld      de,NEWKEY
        ld      a,($FBEB)
        rrca
        jr      nc,code_shift
        ld      hl,scode_tbl
        jr      scan_start
code_shift
        ld      hl,scode_tbl_shift
scan_start
        ld      b,$0b
key_chk_lp
        ld      a,(de)
        cpl
        and     a,(ix)
        ld      c,$08
key_bit_lp
        rrca
        jr      c,push_pnt
        inc     hl
        dec     c
        jr      nz,key_bit_lp
        inc     ix
        inc     de
        djnz    key_chk_lp
        ret
push_pnt
        push    hl
        push    de
        push    bc
        ld      a,(hl)
        and     a,a
        ; if RegA was no charater then don't be stock.
        jr      z,pnt_flow
        ld      c,a
        ld      de,LIMPNT
        ld      hl,(PUTPNT)
        call    wordcomp
        jr      nc,pnt_flow
        ld      a,c
        ld      (hl),a
        inc     hl
        ld      (PUTPNT),hl
pnt_flow
        pop     bc
        pop     de
        pop     hl
        ret

key_int
        ld      hl,NEWKEY
        ld      bc,$0006
        add     hl,bc
        ld      a,(hl)
        and     a,$01
        jr      nz,ki_end
        call    dbg_reg
ki_end
        ret

;-------------------
        org     $1000

        ld      a,$82
        out     (PPI_REGS),a

        ld      a,$C9
        ld      (H_KEYI),a
        ld      (H_TIMI),a

        ei

hang_up_mode
        ld      a,$06
        call    in_keyboard
        bit     0,a
        jp      z,debug_mode

        halt

        jp      hang_up_mode

        org     $1020
stack_error
        call    H_STKE
        ld      de,str_stack_error
        jp      print_error

;------------------------------------
;call basic.
call_basic_intr
        ld      de,str_no_basic_intr
        jp      print_error

;------------------------------------
;display error.
;in DE=address of message.

print_error
        in      a,(VDP_STAT) ; reset Latch 
        ld      hl,vdp_bios
        ld      b,$0C
        ld      c,VDP_ADDR
	otir

        ld      bc,$0800
lp_clearmem
        xor     a,a
        out     (VDP_DATA),a
        dec     bc
        ld      a,b
        or      a,c
        jr      nz,lp_clearmem

        ld      hl,MSXFont
        ld      bc,$1000
lp_fontset
        ld      a,(hl)
        out     (VDP_DATA),a
        inc     hl
        dec     bc
        ld      a,b
        or      a,c
        jr      nz,lp_fontset

;set cursor to (0,0)
        ld      a,$00
        out     (VDP_ADDR),a
        ld      a,$40
        out     (VDP_ADDR),a

        ld      hl,str_error_prompt

        ld      a,(hl)
lp_errprn
        out     (VDP_DATA),a
        inc     hl
        ld      a,(hl)
        and     a,a
        jr      nz,lp_errprn

        ld      a,(de)
lp_strprn
        out     (VDP_DATA),a
        inc     de
        ld      a,(de)
        and     a,a
        jr      nz,lp_strprn

        jp      hang_up_mode


;------------------------------------
;the disk routines
;------------------------------------

DISKIO  equ     $4010

disk_intr
        ld      hl,str_flist
        call    prn_text

        xor     a,a
        ld      bc,$01F9
        ld      de,$0000
        ld      hl,$C000
        and     a,a

        call    DISKIO
        jp      c,disk_error
        ld      hl,($C00B)

        ; byte of sector / 0x20(file structure)

        ld      b,5        
shift_adr
        and     a,a
        rr      h
        rr      l
        djnz    shift_adr        

        ld      ($E100),hl

        ld      a,($C010)
        ld      b,a
        ld      hl,$0001
        ld      de,($C016)
dsk_lp
        add     hl,de
        djnz    dsk_lp

        ex      de,hl
        xor     a,a
        ld      bc,$01F9
        ld      hl,$C000
        and     a,a
        call    DISKIO
        jp      c,disk_error

        ld      ix,$C000

        ld      a,($E100)
        ld      c,a

file_lp
        ld      a,(ix)
        and     a,a
        jp      z,end_lp
        ld      b,8
name_lp
        ld      a,(ix)
        inc     ix
        call    ch_put
        djnz    name_lp

        ld      a,'.'
        call    ch_put

        ld      b,3
ext_lp
        ld      a,(ix)
        inc     ix
        call    ch_put
        djnz    ext_lp

        ld      de,$0015
        add     ix,de

        ld      hl,str_crlf
        call    prn_text

        dec     c
        jr      nz,file_lp

end_lp
        
        jp      hang_up_mode

;        ld      de,str_disk
;        jp      print_error

disk_error
        push    af
        ld      hl,str_diskerr
        call    prn_text
        pop     af
        ld      b,0
        ld      c,a
        ld      hl,str_de_addr
        add     hl,bc

        ld      e,(hl)
        inc     hl
        ld      d,(hl)

        ex      de,hl
        call    prn_text

        jp      hang_up_mode
        


;---------------------------------
;system messages
;---------------------------------

str_proginfo
;                0123456789012345678901234567890123456789 
        db      "MSX COMPATIBLE BIOS ver 0.13",$0d,$0a
        db      "Copyright (C) 2002 BouKiCHi",$0d,$0a
        db      $00

str_thanks
        db      $0d,$0a
        db      "special thanks ...",$0d,$0a
        db      "http://retropc.net/",$0d,$0a
        db      "http://www.vorc.org/",$0d,$0a
        db      $0d,$0a,$00

str_slot
        db      $0d,$0a,"slot:",$00
str_chksum
        db      $0d,$0a,"checksum:",$00
str_isgame
        db      " game:",$00

;-------------------------------------
;error messages
str_error_prompt
;
        db      "ERROR:",$00
str_memory_err
;
        db      "MEMORY NOT FOUND.",$00

str_no_basic_intr
;
        db      "CALLED NO EXISTANCE BASIC.",$00

str_disk
;
        db      "CALLED DISK ROUTINE.",$00

str_stack_error
;
        db      "STACK ERROR.",$00
str_secretmsg
;
        db      $0d,$0a
        db      "     "
        db      "  !!",$0d,$0a,$00

str_crlf
        db      $0d,$0a,$00

str_flist
        db      $0d,$0a,"--- display disk file list ---",$0d,$0a,$00

str_diskerr
        db      "Disk Error:",$00

str_de_addr
        dw str_de_wp
        dw str_de_nr
        dw str_de_de
        dw str_de_se
        dw str_de_rn
        dw str_de_wf
        dw str_de_oe

str_de_wp
        db      "Write protected",$0d,$0a,$00
str_de_nr
        db      "Not ready",$0d,$0a,$00
str_de_de
        db      "Data (CRC) error",$0d,$0a,$00
str_de_se
        db      "Seek error",$0d,$0a,$00
str_de_rn
        db      "Record not found",$0d,$0a,$00
str_de_wf
        db      "Write fault",$0d,$0a,$00
str_de_oe
        db      "Other Error",$0d,$0a,$00


str_canstst
        db      $0d,$0a
        db      "SOUND TEST [F3 Key]",$00

str_nocart
;                0123456789012345678901234567890123456789 
        db      $0d,$0a
        db      "        Cartridge not found.",$00

str_run
;               [0123456789012345678901234567890123456789] 
        db      $0d,$0a,$0d,$0a
        db      "           Starting...",$00

str_s_test
;               [0123456789012345678901234567890123456789] 
        db      $0d,$0a,$0d,$0a
        db      "           SOUND TEST MODE",$00


hex_tbl
        db      "0123456789ABCDEF",$00
reg_tbl
        db      "PC: IY: IX: HL: DE: BC: AF: ",$00

; scancode table
scode_tbl
        db      "01234567"       ;00
        db      "89-^\@[;"       ;01
        db      ":],./_ab"       ;02
        db      "cdefghij"       ;03
        db      "klmnopqr"       ;04
        db      "stuvwxyz"       ;05
        db      $00,$00,$00,$00,$00,$00,$00,$00 ;06
        db      $00,$00,$1B,$09,$00,$08,$00,$0D ;07
        db      $20,$00,$00,$00,$1D,$1E,$1F,$1C ;08
        db      $00,$00,$00,$00,$00,$00,$00,$00 ;09
        db      $00,$00,$00,$00,$00,$00,$00,$00 ;0a

scode_tbl_shift
        db      "0!",$22,"#$%&'" ;00
        db      "()=~|`{+"       ;01
        db      "*}<>?_AB"       ;02
        db      "CDEFGHIJ"       ;03
        db      "KLMNOPQR"       ;04
        db      "STUVWXYZ"       ;05
        db      $00,$00,$00,$00,$00,$00,$00,$00 ;06
        db      $00,$00,$1B,$09,$00,$08,$00,$0D ;07
        db      $20,$00,$00,$00,$1D,$1E,$1F,$1C ;08
        db      $00,$00,$00,$00,$00,$00,$00,$00 ;09
        db      $00,$00,$00,$00,$00,$00,$00,$00 ;0a

vdp_bios
        db      $00,$80,$70,$81,$00,$82,$01,$84
        db      $f5,$87,$00,$40

;--------------------------
; the routines of sound test. 
;--------------------------

        org     $2000

sound_mode
        di

        ld      a,$FF
        ld      (PSG_DBG),a


        call    get_slotreg
        rrca
        rrca
        and     $03             ; A=CART ROM slot

        ld      hl,$8000
        call    enaslt         ; duplicate page1 to page2

        ; takeover the hook.

        ld      a,$C9
        ld      (H_KEYI),a
        ld      (H_TIMI),a

        call    clr_text40

        ; display zero.

        xor     a,a
        ld      de,$0000

        ld      b,$10
pdsp_lp
        call    disp_psg
        inc     d
        djnz    pdsp_lp


        ld      hl,str_s_test
        call    prn_text

        call    chk_mus_lst

        call    sndmod_play

        xor     a,a
        ld      (SMOD_OLDKEY),a

;-----------------------------
; sound routine main loop
snd_loop
        halt
        ld      hl,(SMOD_PLAY)
        call    call_hl

        ld      a,$08
        call    in_keyboard
        ld      b,a
        ld      a,(SMOD_OLDKEY)
        cp      a,b
        jr      z,snd_loop
        ld      a,b
        ld      (SMOD_OLDKEY),a

        bit     6,a
        jr      z,snd_down
        bit     5,a
        jr      z,snd_up
        bit     0,a
        jp      z,debug_mode
        jp      snd_loop

;--------------------------
snd_down
        ld      a,(SMOD_REQNUM)
        inc     a
        jr      snd_set
snd_up
        ld      a,(SMOD_REQNUM)
        dec     a
snd_set
        call    chk_snd_rng
        ld      (SMOD_REQNUM),a
        call    sndmod_play
        jr      snd_loop

;---------------------------
; check range of request number.
chk_snd_rng
; dest AF,HL,B
; check music list.

        ld      b,a
        ld      hl,(SMOD_MUSLST)
        ld      a,h
        or      a,a
        jr      nz,m_lst_rng
        ld      a,b
        ret
m_lst_rng
        ld      hl,(SMOD_MUSLST)
        ld      a,(hl) ; A=6 A>B
        cp      a,b
        jr      c,m_rng_ng
        ld      a,b
        ret
m_rng_ng
        ld      a,(SMOD_REQNUM)
        ret

;----------------------
chk_mus_lst
; check music list.

        ld      hl,(SMOD_MUSLST)
        ld      a,h
        or      a,a
        jr      nz,m_list_fnd

        ld      a,l ; L=REQNO
        ld      (SMOD_REQNUM),a
        ret
m_list_fnd
        ld      a,$00
        ld      (SMOD_REQNUM),a
        ret

;---------------------------
sndmod_play

        call    sound_memclr


        ld      hl,(SMOD_MUSLST)
        ld      a,h
        or      a,a
        jr      z,sndmod_hex

        push    hl
        pop     ix
        inc     ix

        ld      a,(SMOD_REQNUM)

        ld      b,0
        ld      c,a
        add     ix,bc
        add     ix,bc
        add     ix,bc
        add     ix,bc

        call    set_name_adrs

        ld      l,(ix+2)
        ld      h,(ix+3)
        call    prn_str_disp
        ld      a,(ix)

        ld      hl,(SMOD_INIT)
        call    call_hl
        ret

sndmod_hex
        call    set_name_adrs
        ld      a,(SMOD_REQNUM)
        call    vout_hex8
        ld      a,(SMOD_REQNUM)

        ld      hl,(SMOD_INIT)
        call    call_hl
        ret

;---------------------------
call_hl
        jp      (hl)

;------------------------
set_name_adrs
        ld      de,120
        call    de2curs
        xor     a,a
        ld      bc,(wrvdpa)
        ld      b,40
fill_rep
        call    ch_put
        djnz    fill_rep

        ld      de,128
        call    de2curs
        ret

sound_memclr
        xor     a,a
        ld      hl,$c000
        ld      de,$c001
        ld      bc,$3000
        ld      (hl),a
        ldir
        ret

disp_psg
        push    hl
        push    de
        push    bc
        push    af

        ld      a,d
        cp      a,8
        jr      nc,disp_l9
        ld      bc,320
        jr      disp_main
disp_l9
        sub     a,8
        ld      d,a
        ld      bc,360
disp_main
        ld      h,0
        ld      l,d

        add     hl,hl
        add     hl,hl

        add     hl,bc

        ex      de,hl
        call    de2curs
        ex      de,hl

        ld      a,e

        call    vout_hex8

        pop     af
        pop     bc
        pop     de
        pop     hl
        ret


;-------------------------
check_sum
        xor     a,a
        ld      bc,$4000
        ld      hl,$4000
        ld      de,$0000
csum_lp
        ld      a,(hl)
        add     a,e
        ld      e,a
        jr      nc,csum_nc
        inc     d
csum_nc
        inc     hl
        dec     bc

        ld      a,b
        or      a,c
        jr      nz,csum_lp

        ;DE = checksum

        push    de

        ld      hl,str_chksum
        call    prn_text

        pop     ix
        push    ix

        call    vout_hex16

        ld      hl,str_isgame
        call    prn_str_disp

        pop     hl
        ld      (SMOD_ROMSUM),hl
        ld      bc,$000A     ; size of one structure.

        ld      ix,sum_table
cs_nam_loop
        ld      a,(ix)
        or      a,(ix+1)
        jr      z,cs_nam_skip


        ld      a,(ix)
        cp      a,l
        jr      nz,cs_nam_next
        ld      a,(ix+1)
        cp      a,h
        jr      nz,cs_nam_next

        jr      cs_nam_skip

cs_nam_next
        add     ix,bc
        jr      cs_nam_loop
cs_nam_skip

        ld      a,(ix+4)
        ld      l,a
        ld      a,(ix+5)
        ld      h,a
        ld      (SMOD_MUSLST),hl

        ld      a,(ix+6)
        ld      l,a
        ld      a,(ix+7)
        ld      h,a
        ld      (SMOD_INIT),hl

        ld      a,(ix+8)
        ld      l,a
        ld      a,(ix+9)
        ld      h,a
        ld      (SMOD_PLAY),hl

        ld      a,(ix+2)
        ld      l,a
        ld      a,(ix+3)
        ld      h,a

        call    prn_str_disp
        inc     hl
        ld      a,(hl)
        ld      (SMOD_TSTSND),a
        ret


;-----------------------------

sum_table
                ;CSUM,PTR_GAMENAME,LIST_MUSIC  ,INIT ,PLAY
                ;------------------------------------------
        dw      $0d0f,name_goonies,list_mus_gns,$B590,$B641
        dw      $a453,name_twinscc,$0000       ,$0000,$0000
        dw      $b49f,name_zanac  ,$0000       ,$0000,$0000
        dw      $9ae8,name_kungfu ,$0000       ,$0000,$0000
        dw      $008f,name_g1942  ,$0000       ,$0000,$0000
        dw      $665a,name_pooyan ,$0000       ,$0000,$0000
        dw      $0000,name_unknown,$0000       ,$0000,$0000 ; NULL
name_goonies
        db      "GOONIES",$0,$FF
name_twinscc
        db      "TWINBEE(SCC)",$0,$FF
name_zanac
        db      "ZANAC",$0,$0
name_kungfu
        db      "KUNGFU",$0,$0
name_g1942
        db      "1942",$0,$0
name_pooyan
        db      "POOYAN",$0,$0
name_unknown
        db      "UNKNOWN",$0,$0

list_mus_gns
        ; list length

        db      $1c
        dw      $009B,gns_theme   
        dw      $0091,gns_mus1   
        dw      $0098,gns_mus2   
        dw      $00A1,gns_mus3   
        dw      $00A4,gns_mus4   
        dw      $00A7,gns_mus5   
        dw      $00AA,gns_mus6   
        dw      $0081,gns_mus7   
        dw      $0085,gns_mus8   
        dw      $0089,gns_mus9   
        dw      $008E,gns_mus10   
        dw      $0001,gns_se1
        dw      $0002,gns_se2
        dw      $0003,gns_se3
        dw      $0004,gns_se4
        dw      $0005,gns_se5
        dw      $0006,gns_se6
        dw      $0007,gns_se7
        dw      $0008,gns_se8
        dw      $0009,gns_se9
        dw      $000A,gns_se10
        dw      $000B,gns_se11
        dw      $000C,gns_se12
        dw      $000D,gns_se13
        dw      $000E,gns_se14
        dw      $000F,gns_se15
        dw      $0010,gns_se16
        dw      $0011,gns_se17
        dw      $0012,gns_se18
        dw      $0000,$0000   ; NULL

gns_theme
        db      "THE THEME OF GOONIES",$0
gns_mus1
        db      "MUSIC 1",$0
gns_mus2
        db      "MUSIC 2",$0
gns_mus3
        db      "MUSIC 3",$0
gns_mus4
        db      "MUSIC 4",$0
gns_mus5
        db      "MUSIC 5",$0
gns_mus6
        db      "MUSIC 6",$0
gns_mus7
        db      "MUSIC 7",$0
gns_mus8
        db      "MUSIC 8",$0
gns_mus9
        db      "MUSIC 9",$0
gns_mus10
        db      "MUSIC 10",$0


gns_se1
        db      "S.E.1",$0
gns_se2
        db      "S.E.2",$0
gns_se3
        db      "S.E.3",$0
gns_se4
        db      "S.E.4",$0
gns_se5
        db      "S.E.5",$0
gns_se6
        db      "S.E.6",$0
gns_se7
        db      "S.E.7",$0
gns_se8
        db      "S.E.8",$0
gns_se9
        db      "S.E.9",$0
gns_se10
        db      "S.E.10",$0
gns_se11
        db      "S.E.11",$0
gns_se12
        db      "S.E.12",$0
gns_se13
        db      "S.E.13",$0
gns_se14
        db      "S.E.14",$0
gns_se15
        db      "S.E.15",$0
gns_se16
        db      "S.E.16",$0
gns_se17
        db      "S.E.17",$0
gns_se18
        db      "S.E.18",$0


;------------
;new type hook routine.(for debug)
        org     $3232
debug_test
        ret

        include "font_fh.z80"
        include "font_sh.z80"

        align
        org     $3FFF
        nop
        end     Start

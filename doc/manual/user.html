<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <link title="Purple" rel="stylesheet" href="manual-purple.css" type="text/css">
  <link title="Minty" rel="alternate stylesheet" href="manual-minty.css" type="text/css">
  <link title="Plain" rel="alternate stylesheet" href="manual.css" type="text/css">
  <title>openMSX User's Manual</title>
</head>

<body>

<h1>openMSX User's Manual</h1>

<h2>Contents</h2>

<ol class="toc">
	<li><a class="internal" href="#intro">1. Introduction</a>
		<ol class="toc">
			<li><a class="internal" href="#newver">1.1 New Versions of This Document</a></li>
			<li><a class="internal" href="#purpose">1.2 Purpose</a></li>
			<li><a class="internal" href="#history">1.3 Revision History</a></li>
			<li><a class="internal" href="#terms">1.4 Important Terms</a></li>
		</ol>
	</li>
	<li><a class="internal" href="#starting">2. Starting the Emulator</a>
		<ol class="toc">
			<li><a class="internal" href="#machines">2.1 Machines</a></li>
			<li><a class="internal" href="#extensions">2.2 Extensions</a></li>
			<li><a class="internal" href="#otheroptions">2.3 Other Command Line Options</a></li>
		</ol>
	</li>
	<li><a class="internal" href="#controlling">3. The Console and Settings</a>
		<ol class="toc">
			<li><a class="internal" href="#console">3.1 Console Introduction</a></li>
			<li><a class="internal" href="#importantconsole">3.2 Some Simple Console Commands</a></li>
			<li><a class="internal" href="#settings">3.3 Settings</a></li>
			<li><a class="internal" href="#plug">3.4 Plugging in devices in connectors</a></li>
		</ol>
	</li>
	<li><a class="internal" href="#gui">4. The Graphical User Interface</a>
		<ol class="toc">
			<li><a class="internal" href="#guioverview">4.1 Overview</a></li>
			<li><a class="internal" href="#guimainmenu">4.2 Main menu bar</a></li>
			<li><a class="internal" href="#guiother">4.3 Other default GUI elements</a></li>
			<li><a class="internal" href="#guiadvanced">4.4 Advanced topics</a></li>
		</ol>
	</li>
	<li><a class="internal" href="#media">5. Running MSX Software and Using Media</a>
		<ol class="toc">
			<li><a class="internal" href="#roms">5.1 Running ROM Software</a></li>
			<li><a class="internal" href="#disks">5.2 Running Disk Software</a>
				<ol class="toc">
					<li><a class="internal" href="#diskimages">5.2.1 Using Disk Images</a></li>
					<li><a class="internal" href="#dirasdisk">5.2.2 Using Directories as Disks</a></li>
					<li><a class="internal" href="#realdisks">5.2.3 Using Real Disks</a></li>
					<li><a class="internal" href="#diskmanagement">5.2.4 Managing Disk Images</a></li>
				</ol>
			</li>
			<li><a class="internal" href="#tape">5.3 Running Tape Software</a>
				<ol class="toc">
					<li><a class="internal" href="#cas">5.3.1 Using CAS/TSX files</a></li>
				</ol>
			</li>

			<li><a class="internal" href="#harddisks">5.4 Emulating MSX Harddisks, SD interfaces and CD-ROM</a>
				<ol class="toc">
					<li><a class="internal" href="#ide">5.4.1 Sunrise IDE</a></li>
					<li><a class="internal" href="#beeride">5.4.2 Beer IDE</a></li>
					<li><a class="internal" href="#scsi">5.4.3 SCSI devices</a></li>
					<li><a class="internal" href="#sd">5.4.4 MegaFlashROM SCC+ SD</a></li>
				</ol>
			</li>

			<li><a class="internal" href="#laserdisc">5.5 Running Laserdisc Software</a></li>
		</ol>
	</li>

	<li><a class="internal" href="#input">6. Input Devices</a>
		<ol class="toc">
			<li><a class="internal" href="#keyboard">6.1 Keyboard</a>
				<ol class="toc">
					<li><a class="internal" href="#msxkeymapping">6.1.1 MSX Key Mapping</a></li>
					<li><a class="internal" href="#cvkeymapping">6.1.2 ColecoVision Key Mapping</a></li>
					<li><a class="internal" href="#emukeymapping">6.1.3 Emulator Functions Key Mapping</a></li>
					<li><a class="internal" href="#keyboardlayouts">6.1.4 Keyboard Layouts</a></li>
				</ol>
			</li>
			<li><a class="internal" href="#joystick">6.2 Joystick</a></li>
			<li><a class="internal" href="#mouse">6.3 Mouse</a></li>
			<li><a class="internal" href="#arkanoidpad">6.4 Arkanoid Pad</a></li>
			<li><a class="internal" href="#trackball">6.5 Trackball</a></li>
			<li><a class="internal" href="#touchpad">6.6 Touchpad</a></li>
			<li><a class="internal" href="#magickey">6.7 Magic Key</a></li>
			<li><a class="internal" href="#ninjatap">6.8 Ninja Tap</a></li>
			<li><a class="internal" href="#tetris2dongle">6.9 Tetris II Special Edition dongle</a></li>
			<li><a class="internal" href="#msxpaddle">6.10 MSX Paddle</a></li>
			<li><a class="internal" href="#circuitdesignerdongle">6.11 Circuit Designer RD dongle</a></li>
		</ol>
	</li>

	<li><a class="internal" href="#video">7. Video</a>
		<ol class="toc">
			<li><a class="internal" href="#scalers">7.1 Scalers</a></li>
			<li><a class="internal" href="#gamma">7.2 Gamma Correction</a></li>
			<li><a class="internal" href="#videoeffects">7.3 Special Effects</a></li>
			<li><a class="internal" href="#accuracy">7.4 Accuracy</a></li>
			<li><a class="internal" href="#gfx9000">7.5 GFX9000/Video 9000</a></li>
			<li><a class="internal" href="#recording">7.6 Video Recording</a></li>
		</ol>
	</li>

	<li><a class="internal" href="#audio">8. Audio</a>
		<ol class="toc">
			<li><a class="internal" href="#audiosettings">8.1 Audio Settings</a></li>
			<li><a class="internal" href="#midi">8.2 MIDI</a></li>
			<li><a class="internal" href="#soundlogger">8.3 Recording Audio to File</a></li>
		</ol>
	</li>

	<li><a class="internal" href="#usefulextras">9. Useful Extras</a>
		<ol class="toc">
			<li><a class="internal" href="#savestate">9.1 Saving/Loading the State of the Machine</a></li>
			<li><a class="internal" href="#reverse">9.2 Reverse</a></li>
			<li><a class="internal" href="#trainer">9.3 Game Trainer</a></li>
			<li><a class="internal" href="#debugdevice">9.4 Debug Device</a>
				<ol class="toc">
					<li><a class="internal" href="#debugdeviceenable">9.4.1 Enabling the Debug Device</a></li>
					<li><a class="internal" href="#debugdeviceports">9.4.2 Output Ports</a></li>
					<li><a class="internal" href="#debugdevicemode1">9.4.3 Single Byte Mode</a></li>
					<li><a class="internal" href="#debugdevicemode2">9.4.4 Multi Byte Mode</a></li>
				</ol>
			</li>
			<li><a class="internal" href="#programmabledevice">9.5 Programmable Device</a>
				<ol class="toc">
					<li><a class="internal" href="#programmabledeviceenable">9.5.1 Enabling the Programmable Device</a></li>
					<li><a class="internal" href="#programmabledeviceports">9.5.2 Device Ports and callbacks</a></li>
				</ol>
			</li>
			<li><a class="internal" href="#sdcdb">9.6 SDCC Debugger</a></li>
		</ol>
	</li>
	<li><a class="internal" href="#contact">10. Contact Info</a></li>
</ol>


<h2><a id="intro">1. Introduction</a></h2>

<h3><a id="newver">1.1 New Versions of This Document</a></h3>
<p>
The manual for the latest openMSX release can be found on the openMSX home page:
</p>
<p>
<a class="external" href="http://openmsx.org/manual/">http://openmsx.org/manual/</a>
</p>

<h3><a id="purpose">1.2 Purpose</a></h3>
<p>
This manual is about openMSX, the open source MSX emulator that tries to achieve
near-perfect emulation by using a novel emulation model.
You can find more information about openMSX on the
<a class="external" href="http://openmsx.org/">openMSX home page</a>.
You can also download the emulator itself from there.
</p>

<p>
openMSX is not completed yet, which means that most things work but not all
features are implemented yet.
Many emulation features are implemented, but not all of them are represented
yet in the built-in Graphical User Interface. To get the most out of openMSX,
we have written this guide.
</p>

<p>
This manual tells you how you can use openMSX, once it has been installed and
properly set up. You should be able to use most of the features of openMSX if
you have read it.
If you are only using the GUI menus of openMSX, you don't have to pay attention
to the exact command and setting names. However it is still useful to read this
document to find out how openMSX works and learn its terminology.
</p>

<p>
<em>Disclaimer:</em>
We do not claim this guide is complete or even correct.
What you do with the information in it is entirely at your own risk.
We just hope it helps you enjoy openMSX more.
</p>

<h3><a id="history">1.3 Revision History</a></h3>

<p>
For the revision history, please refer to the <a class="external"
href="https://github.com/openMSX/openMSX/commits/master/doc/manual/user.html">commit log</a>.
</p>

<h3><a id="terms">1.4 Important Terms</a></h3>

<p>
First some terms. Users of real MSX computers will probably not find it hard to understand these, but we'll explain what we mean with them to make sure the terms used in openMSX are clear for everyone.
<p>

<dl>
<dt>Machine</dt>
<dd>With a machine we denote a single instance of a particular MSX computer. The bare computer, with a manufacturer name and a type name, just as they were sold.</dd>
<dd>In case you're not too familiar with MSX: it's a standard, and many manufacturers created several MSX compatible computer models. openMSX tries to emulate them all and you can choose which particular brand and model you want to emulate.</dd>
<dt>Extensions</dt>
<dd>All standard MSX computers have cartridge slots in which extension cartridges can be plugged into. They can be anything, like external disk drives, sound cartridges, serial interfaces, video cards, and multi-cartridges like the Carnivore 2 or the MegaFlashROM SCC+ SD.</dd>
<dd>Technically, a game (ROM) cartridge you put in a cartridge slot is also a form of an extension. See also below under Media.</dd>
<dd>For technical reasons, some extension cartridges in openMSX do not take up a cartridge slot ("I/O only extensions").</dd>
<dt>Connectors</dt>
<dd>The bare MSX machine has connectors to which equipment can be plugged of which the plug matches the connector (called "pluggables" here and there).</dd>
<dd>Examples are printers, joysticks, mice, dongles, MIDI equipment, ...</dd>
<dd>openMSX does not allow you to plug in equipment in the wrong connector type.</dd>
<dd>Some equipment is automatically plugged in for your convenience, e.g. the Tape Deck if your machine has a cassette connector.</dd>
<dt>Media</dt>
<dd>These are containers with software on them. For example: ROM cartridges, floppy disks and cassette tapes.</dd>
<dd>Depending on the MSX machine you are using, different media can be inserted. If the machine you are emulating does not have a disk drive, you cannot insert a floppy disk (image) into the machine. However, like in the real world, if you first insert an external disk drive extension into one of the cartridge slots of the machine, you can insert a floppy disk into the disk drive you just connected to the MSX.</dd>
<dd>Media are always represented by an "image" of their content, which is just a file containing the relevant data of the media. So, a ROM cartridge is represented by a ROM file (which is just the data from the ROM chips), floppy disks by disk image files, cassette tapes with tape image files, etc. This manual may use also these "image" terms to refer to media.</dd>
<dt>Setups</dt>
<dd>A setup is the combination of a bare MSX machine, with its plugged in extensions, plugged in equipment via the machine's connectors and the media in the available media slots.</dd>
<dd>When creating a new setup, you can specify up to what depth level the setup must be saved: either just the machine, or including the extensions, or also including the plugged in equipment or even including the inserted media.</dd>
<dd>The setups feature allows you like in the real world to turn off your setup and use it quickly again later.</dd>
</dl>

<h2><a id="starting">2. Starting the Emulator</a></h2>

<p>
In this chapter we will tell you how to select MSX machines and how to use extension cartridges, when starting up openMSX.
</p>

<h3><a id="machines">2.1 Machines</a></h3>

<p>
If you start openMSX without any command line parameters, you will get the
default machine, which is stored in the <code><a class="external"
href="commands.html#default_machine">default_machine</a></code> setting. If you did
not change the default machine, the C-BIOS MSX2+ machine will be started.
</p>

<p>
However, if you created a setup earlier and marked it as the default setup (via the <code><a class="external"
href="commands.html#default_setup">default_setup</a></code> setting), that setup
will be loaded instead. This can be useful to always start up with your favourite
setup.
</p>

<p>
To select machines from the GUI, click <span class="menu-reference">Main menu
bar &rarr; Machine &rarr; Select MSX machine...</span> This will
give a window in which you can see an overview of all available machines to
select from and hovering on items in the list shows you the most important
properties of these machines. You can also filter on type, region or any part
of the machine names. You can replace the current machine, or run another
machine along the existing running machines. An overview of the running
machines is shown at the top of the machine selection window, where you can
also change the default machine.
</p>

<p>
To select a different MSX machine from the command line, you can use the
<code>-machine</code> argument:
</p>
<div class="commandline">
    openmsx -machine Panasonic_FS-A1GT
</div>
<p>
It is also possible to use the <code><a class="external"
href="commands.html#machine">machine</a></code> command to switch at run time
in the <a class="internal" href="#console">console</a>, which is explained in
the next chapter.
</p>

<p>
The C-BIOS machines come with ROMs installed; for other machines you will have
to install system ROMs yourself, see the <a class="external"
href="setup.html#systemroms">Setup Guide</a> for details.
You can always use  <span class="menu-reference">Main menu bar &rarr; Machine
&rarr; Test MSX hardware</span> to verify which system ROMs have been (correctly)
installed.
</p>

<p>
If you have saved a setup earlier (using the GUI via <span class="menu-reference">Main menu bar
&rarr; Machine &rarr; Save setup</span> or the <code><a class="external"
href="commands.html#store_setup">store_setup</a></code> command) you can also use the GUI via <span class="menu-reference">Main menu
bar &rarr; Machine &rarr; Load setup</span> to go from that setup. But also
here you can use the command line (via the <code>-setup</code> command line
option) or the console (via the <code><a class="external"
href="commands.html#setup">setup</a></code> command).
</p>

<h3><a id="extensions">2.2 Extensions</a></h3>

<p>
Extensions are simply MSX cartridges (extensions to the MSX system) that you
can plug into the emulated MSX. openMSX ships with a lot of predefined
extensions. Note that many of them require firmware ROMs (called system ROMs);
see the <a class="external" href="setup.html#systemroms">Setup Guide</a> for
details.
</p>

<p>
Using the GUI, use the <span class="menu-reference">Main menu bar &rarr;
Media</span> menu where you can either first select the MSX cartridge slot to
put the extension into, or directly select the <span class="menu-reference">Extensions</span> menu option to insert
an extension in the first free slot or remove extensions from the slot they're
in.
</p>

<p>
Let's now go into details using the FMPAC as an example. openMSX ships with a
definition (XML file) for the FMPAC extension, but you will have to <a
class="external" href="setup.html#installrom">add</a> the
<code>fmpac.rom</code> firmware ROM yourself. When you have done so, you can
insert an FMPAC into the emulated MSX machine with the following command line:
</p>
<div class="commandline">
    openmsx -ext fmpac
</div>
<p>
Similar to machines, you can also use the <code><a class="external"
href="commands.html#ext">ext</a></code> command in the console to do it at run
time. You can also use something like <code>-extb</code> to explicitly specify
cartridge slot B.
</p>

<p>
If you look in the <code>share/extensions</code> directory (or when using the
console, type the TAB key with the <code>ext</code> command, see next chapter),
you will see all the extensions known to openMSX. For example <code>-ext
mbstereo</code> gives you the MoonBlaster stereo effect: FMPAC on the left
speaker and MSX-AUDIO on the right speaker.
</p>

<h3><a id="otheroptions">2.3 Other Command Line Options</a></h3>

<p>
Some of the most used command line options will be discussed later in this manual.
For a complete list of them, type the following command:
</p>
<div class="commandline">openmsx -h</div>

<h2><a id="controlling">3. The Console and Settings</a></h2>

<h3><a id="console">3.1 Console Introduction</a></h3>

<p>
Most functionality can nowadays be controlled via the built in GUI, using the
main menu bar as a starting point. This will be sufficient for most users.
Originally, this GUI wasn't available and most functionality had to be
controlled differently. This way of control is still available (and will remain
so); this section will tell you more about it. You don't need to care about any
of these commands if the GUI is sufficient for you, but we still recommend having a look at the sections about "Settings"
and "Plugging in devices in connectors".
</p>

<p>
openMSX has a built-in command interface called the <em>console</em>,
which allows you to control almost all aspects of openMSX while it is running.
To access the console, make sure to have the main emulator window selected, and then press F10
(with <a class="internal" href="#keymapping">default key mapping</a>; Cmd+L on
Mac).  This will
open a window with a command line inside the main openMSX window.
</p>

<p>
Typing <a class="external" href="commands.html#help"><code>help</code></a>
gives a list of commands. Using PageUp you can see all of them. If you type
<code>help [command]</code> you will get help for the specified command. This
manual describes a few important commands; a full list can be found in the <a
class="external" href="commands.html">Console Command Reference</a>. The
console can be used to <a class="internal" href="#disks">change disk
images</a>, plug in <a class="internal" href="#joystick">joysticks</a> or <a
class="internal" href="#mouse">mice</a>, <a class="internal"
href="#settings">change settings</a> at run time and to change key bindings,
among others. It actually gives you full control of openMSX: if it can't be
done via the console, it's probably impossible!
</p>

<p>
One very practical feature of the console command line is that you can use
"completion" features. Just try typing half a command and then press the TAB
key; openMSX will then try to finish the word you were typing or show the
possibilities in case of ambiguities. You can use it also for file names,
connectors, pluggables and settings, and even for machine and extension names.
</p>

<p>The console has very common keyboard controls, similar to most text editors.
It also supports copy/paste. Some other controls may be less obvious: </p>

<table>
  <tr> <th>key(s)                 </th> <th>function                                                     </th> </tr>
  <tr> <td>Up                     </td> <td>show previous command from history (starting with current command line)</td> </tr>
  <tr> <td>Down                   </td> <td>show next command from history (starting with current command line)    </td> </tr>
  <tr> <td>Tab                    </td> <td>attempt completion of current command                        </td> </tr>
  <tr> <td>Enter/Return           </td> <td>execute command line                                         </td> </tr>
</table>

<h3><a id="importantconsole">3.2 Some Simple Console Commands</a></h3>

<p>
You can reset your MSX with the console command <code><a class="external"
href="commands.html#reset">reset</a></code> and exit openMSX with the command
<code><a class="external" href="commands.html#exit">exit</a></code>. As
explained in the previous chapter, you can change machines with the <code><a
class="external" href="commands.html#machine">machine</a></code> command and
you can insert extensions with the <code><a class="external"
href="commands.html#ext">ext</a></code> command (use tab-completion to see the
list of possible extension names). Remove extensions with the <code><a
class="external"
href="commands.html#remove_extension">remove_extension</a></code> command or
get a list of the currently inserted extensions with the <code><a
class="external"
href="commands.html#list_extensions">list_extensions</a></code> command. Other
commands will be discussed later on in this manual.
</p>

<h3><a id="settings">3.3 Settings</a></h3>

<p>
There are many settings in openMSX for customization, changing preferences or
enabling extras. The most important ones are in the <span
class="menu-reference">Main menu bar &rarr; Settings</span> menu in the GUI.
There is also an Advanced item in that menu that will give a huge window with
all possible settings. Usually, you can revert a setting to its default value
via <span class="menu-reference">right click &rarr; Restore default</span> in
the context-menu of that setting.
</p>

<p>
Using the console, you can use the command <code><a class="external"
href="commands.html#set">set</a></code> to change any setting. E.g., you can
use it to set the current <a class="internal" href="#scalers">scaler</a>. Issuing
<code>set</code> with only the setting name (like <code>set <a class="external"
href="commands.html#scale_algorithm">scale_algorithm</a></code>), queries
the current value of that setting.
Settings that have only two possible values can also be toggled with the
<code><a class="external" href="commands.html#toggle">toggle</a></code>
command (an example is the default key binding of F11 to <code>toggle
fullscreen</code>, see also below). A (hopefully) complete list of settings can
also be found in the <a class="external" href="commands.html">Console Command
Reference</a>. Note that using the "tab completion" feature can help you a lot
in getting an idea of what settings are possible, as it will only complete
possible options. Just try that.
</p>

<p>
Let's give a few examples of common settings and how to change them.
</p>

<p>
If the MSX goes too fast or too slow, adjust the emulation speed with the
<code><a class="external" href="commands.html#speed">speed</a></code> setting,
which has the speed percentage as parameter. So, typing <code>set
speed 120</code>, will run the emulated MSX at 120% of normal MSX speed.
This is useful for debugging purposes (slow down) or when you want to skip
certain parts of a demo for example (speed up). The GUI has this setting under
<span class="menu-reference">Main menu bar &rarr; Settings &rarr; Speed &rarr; Emulation</span>.
</p>

<p>
Some MSX machines like the Panasonic FS-A1GT have built in software (called
firmware) which can be switched on and off via a switch on the machine itself.
In openMSX the internal software is switched off by default, but you can switch
it on with the following setting: <code>set <a class="external"
href="commands.html#firmwareswitch">firmwareswitch</a> on</code>. If the
currently running machine has a firmware switch, a toggle option will show up in
the <span class="menu-reference">Main menu bar &rarr; Machine</span> menu to control it.
</p>

<p>
If you're not really interested in how long a real MSX would take to load
from diskette, cassette or laserdisc, you could enable the full speed when
loading feature: <code>set <a class="external"
href="commands.html#fullspeedwhenloading">fullspeedwhenloading</a> on</code>,
or from the GUI at <span class="menu-reference">Main menu bar &rarr; Settings
&rarr; Speed &rarr; Go full speed when loading</span>. It
runs openMSX at maximum speed whenever it thinks that the MSX is loading. The
drawbacks: it might detect a bit too late that the MSX isn't loading anymore,
so sometimes the first notes of music played right after loading might be
fast. Also, when loading openMSX will use all available CPU power to get
maximum speed; the feature has no influence on the state of the MSX, of course.
</p>

<p>
You can save all your current settings with the <code><a class="external"
href="commands.html#save_settings">save_settings</a></code> command. At start
up, alternative settings files can be loaded by using the <code>-setting</code>
command line option. You can also use the <code><a class="external"
href="commands.html#load_settings">load_settings</a></code> command to load
settings at run time. Settings that are not mentioned in the saved settings
file that you are loading will be untouched. <a class="external"
href="commands.html#save_settings_on_exit">By default</a>, openMSX will
automatically save your settings on exit (whichever way they were changed).
</p>

<h3><a id="plug">3.4 Plugging in devices in connectors</a></h3>

<p>
The <span class="menu-reference">Main menu bar &rarr; Connectors</span> menu
will show you all connectors of the currently running
machine and which (pluggable) device is currently plugged in. You can easily
plug in other devices there, e.g. a mouse in a joystick port.
</p>

<p>
Examples of connectors are the joystick ports, the printer port, the MIDI in
and out connector, the cassette port, etc. Examples of pluggables are <a
class="internal" href="#joystick">joysticks</a> and <a class="internal"
href="#mouse">mice</a>, but also printers and MIDI equipment.
</p>

<p>
In the console, you can use the command <code><a class="external"
href="commands.html#plugunplug">plug</a></code> to do this. The command
<code><a class="external" href="commands.html#plugunplug">plug</a></code>
without any parameters will show a list of connectors and what pluggables are
plugged into them. Using <code>plug [connector]</code> will only show what is
plugged into [connector]. It will come as no surprise that the command <code>plug
[connector] [pluggable]</code> will plug the [pluggable] into the [connector].
</p>

<p>
Note that using the "tab completion" feature can help you a lot in getting an
idea of what plug commands are possible, as it will only complete possible
connectors and their possible pluggables. Just give it a try.
</p>

<!--
<p class="todo">
Add the complete list of pluggables here.
</p>
-->

<h2><a id="gui">4. The Graphical User Interface</a></h2>

<h3><a id="guioverview">4.1 Overview</a></h3>

<p>
The Graphical User Interface (GUI) in openMSX has been built with the <a
class="external" href="https://github.com/ocornut/imgui">Dear ImGui
library</a>. It allows the developers to relatively easily build and extend the
GUI for all supported platforms. The price we have to pay is that it only works
on systems with 3D hardware acceleration support and that it does not look (a
lot) like the native GUIs of well-known desktop environments like Windows,
macOS, GNOME or KDE.
</p>

<p>
General help on basic usage of the Dear ImGui features can be found in the
<span class="menu-reference">Main menu bar &rarr; Help &rarr; Dear ImGui user
guide</span> menu option.
</p>

<p>
The current GUI is intended for mouse control. It can (at least
partially) also be controlled with a keyboard, but so far this has not been a major focus of development,
so this will definitely not be optimal. Control via a game controller is
currently disabled, but that may change in future versions.
</p>

<p>
Although the current openMSX release already has a lot of functionality
available via the GUI, it is still incomplete and the user experience could use some love. We appreciate feedback on the GUI a lot and we will try to
improve it in later releases based on your input. Please see section <a
class="internal" href="#contact">10. Contact Info</a> for more
information on how to provide feedback.
</p>

<p>
Almost all commands and settings available in the GUI have an underlying
console command and setting accessible via the console. In several places
these underlying commands are mentioned in this manual. Power users especially
will appreciate all the ways they can manipulate openMSX with external programs, scripts,
or other more advanced methods.
</p>

<h3><a id="guimainmenu">4.2 Main menu bar</a></h3>

<p>
As already mentioned before in this manual, the GUI has a Main menu bar at the
top of the openMSX main window. The menu bar fades out when the MSX screen has
focus. To get it back, move the mouse cursor to the top of the openMSX window.
</p>

<p class="image">
<img src="main_menu_bar.png" width="588" height="22" alt="Main menu bar.">
</p>
<p>
The Main menu bar contains the following top level menus:
</p>
<dl>
<dt>Machine</dt>
<dd>Selecting the different machines (computer models)</dd>
<dd>Saving and loading of setups, i.e. machines including whatever the user put into it.</dd>
<dd>Triggering machine reset and enable or disable power</dd>
<dt>Media</dt>
<dd>Inserting and removing media: ROM or extension cartridges, disks, cassette
tapes, laserdiscs, ...</dd>
<dt>Connectors</dt>
<dd>Controlling which devices are plugged into which connectors:
printers, joysticks, mice, dongles, MIDI equipment, ...</dd>
<dt>Save state</dt>
<dd>All save state and replay related functionality, plus some related settings.</dd>
<dt>Tools</dt>
<dd>Several tools that can make your life easier, like virtual keyboard,
copying and pasting, audio and video capture, disk manipulation/management,
trainers and cheats, audio chip tools and gadgets, etc..</dd>
<dt>Settings</dt>
<dd>A collection of the most important settings for Video, Sound,
Speed, Input, the GUI and Misc settings.</dd>
<dd>An uncategorized alphabetical list with all available settings.</dd>
<dt>Debugger</dt>
<dd>A set of powerful debugging tools for the developer. Practically all
functionality from the old, standalone openMSX debugger has been included.</dd>
<dt>Help</dt>
<dd>Links to get (more) help on using openMSX.</dd>
</dl>

<p>
If you like, you can even undock the main menu bar from the main openMSX
window. This is especially useful if you want to stream the openMSX main
window, without showing your interaction with the openMSX menus.
Use the triangular icon on the left in the Main menu bar to undock or redock
it.
</p>

<h3><a id="guiother">4.3 Other default GUI elements</a></h3>

<p>
Besides the Main menu bar, some other main GUI elements you are likely to see.
Here is a small overview.
</p>

<dl>
<dt>Reverse bar</dt>
<dd><img src="reverse_bar.png" width="245" height="39" alt="Main menu bar."></dd>
<dd>Placed on the lower right of the main openMSX window by default.</dd>
<dd>Fades out when the mouse cursor is not on top of it, by default. So it's often not visible.</dd>
<dd>Select <span class="menu-reference">Right click &rarr; Allow
move</span> and/or (un)select <span class="menu-reference">Right click &rarr;
Hide title</span> to move and resize it, possibly outside the main openMSX
window.</dd>
<dd>Can be disabled via <span class="menu-reference">Main menu bar &rarr; Save
state &rarr; Reverse/replay settings &rarr; Show reverse bar</span>.</dd>
<dd>Blue means it's replaying (with interruption possible), red means it's recording new input and green means it's replaying without interruption possible.</dd>
<dt>OSD icons</dt>
<dd><img src="osd_icons.png" width="516" height="57" alt="Main menu bar."></dd>
<dd>Represent the LEDs on the machines and contain important status icons.</dd>
<dd>Appear in the lower left corner by default.</dd>
<dd>Most icons fade out by default (so typically nothing would be visible).</dd>
<dd>Can be configured via <span class="menu-reference">Main menu bar &rarr;
Settings &rarr; Misc &rarr; Configure OSD icons</span>.</dd>
<dd>Similar to the reverse bar: (un)select "Hide title" and/or "Allow move",
and drag the icons to a new location, possibly outside the main openMSX window,
possibly docked to another window.</dd>
<dt>Status bar</dt>
<dd><img src="status_bar.png" width="739" height="29" alt="Main menu bar."></dd>
<dd>Shows up at the bottom of the main openMSX window and contains some
information about the currently running machine and emulation performance.</dd>
<dd>Disabled by default, can be enabled via <span class="menu-reference">Main
menu bar &rarr; Settings &rarr; Misc &rarr; Show status bar</span>.</dd>
</dl>

<h3><a id="guiadvanced">4.4 Advanced topics</a></h3>

<p>
The GUI allows you to put any window inside the main openMSX window, or outside
of it. But windows can also be docked together, at the (left/right/top/bottom)
edge of any window except the main window, even in a tab bar.
</p>

<p>
The GUI also has specific settings, like shortcuts that can be used in the GUI only.
</p>

<p>
Also, you can save and load layouts of windows that are combined with each
other. This is still a rather rough feature, as it also saves and loads other
data, like the history information from some menus.
</p>

<p>
As an example of a layout, we created one with a debugger focus. The image below shows:
</p>
<ul>
  <li>docking with split windows horizontal/vertical, sometimes multiple times</li>
  <li>docking with tab bar (e.g. memory/VRAM/PSG regs),</li>
  <li>hiding the (sub)window title, as it is often quite obvious. For "stack" this wasn't done on purpose, to show the difference.</li>
</ul>

<p class="image">
<img src="debugger-layout.png" width="935" height="610" alt="Example debugger focused layout.">
</p>

<!--
TODO: extend this section and add screenshots.
Missing topics are possibly: messages (log/configuration), the Simple Note Widget and possibly Drag and Drop.
-->

<h2><a id="media">5. Running MSX Software and Using Media</a></h2>

<p>
With this information, you can run most of the existing MSX software. If you
use the GUI, refer to the <span class="menu-reference">Main menu bar &rarr;
Media</span> menu.
</p>

<p>
For all supported media files, there is a list of filename extensions that are
recognized by openMSX. If you run openMSX from the command line, adding a file
name (with path if necessary) as a command line option, openMSX will insert the
file as the proper type of media. The list of supported extensions for each
media type can be easily retrieved with <code>-h</code> option on the command
line. For some media, examples of command line usage are given below.
</p>

<p>
If you drag and drop a file with one of these supported extensions
into the main openMSX window, openMSX will try to handle it accordingly.
</p>

<h3><a id="roms">5.1 Running ROM software</a></h3>

<p>
In the GUI you can choose which ROM software you want to run by selecting a
Cartridge Slot from the <span
class="menu-reference">Main menu bar &rarr; Media</span> menu. This will open a
window where you can tell openMSX exactly what you want to put in the slot,
like a ROM image, which mapper to use if the automatically selected one isn't
correct, and whether the MSX should be reset after inserting.
</p>
<p>
And finally, you can
also browse for and select (multiple) IPS patches to apply to the selected ROM
image. IPS patches are files that describe a modification of the ROM you are
applying it to, e.g. a translation or a cheat. This way you do not need to
alter the original files.
</p>

<h4>Command line and console</h4>

<p>
Using the command line, suppose you want to run the ROM file
<code>galious.rom</code>. Then you simply type:
</p>
<div class="commandline">openmsx galious.rom</div>
<p>
and the emulated MSX will run the game. (Of course,
in this case, the file <code>galious.rom</code> should be in the current directory.
You can also explicitly indicate that the thing is a ROM image like this:
</p>
<div class="commandline">openmsx -cart galious.gam</div>
<p>
This lets openMSX know that the file <code>galious.gam</code> is a ROM
cartridge and that openMSX should insert it in the first available free
cartridge slot. You can also use <code>-carta</code> to explicitly specify
cartridge slot A.
</p>
<p>
In the event openMSX doesn't have the ROM in the ROM database and fails auto
detection of the mapper type, you can specify the mapper to <code>Konami</code>
(for instance) like this:
</p>
<div class="commandline">openmsx galious.rom -romtype Konami</div>
<p>
Note that in practice you won't need this, because most ROM images are in the
database or auto detected if they are not. The <code>-romtype</code> option
should follow the ROM it applies to immediately on the command line.
</p>

<p>
To apply an IPS patch using the command line, provide the IPS
filename like this:
</p>
<div class="commandline">openmsx -cart galious.rom -ips galiouspatch.ips</div>
<p>
As with the <code>-romtype</code> option, the <code>-ips</code> option on the
command line must follow the ROM file it applies to directly. You can also use
multiple <code>-ips</code> options if you want to apply multiple patches.
</p>

<p>
If you already have openMSX running and want to insert cartridges at runtime
(maybe even when the MSX is powered on), you can use the <code><a
class="external" href="commands.html#cart">carta</a></code> command in the <a
class="internal" href="#console">console</a> as well, which is just as
powerful.
</p>

<h3><a id="disks">5.2 Running Disk Software</a></h3>

<h4><a id="diskimages">5.2.1 Using Disk Images</a></h4>

<p>
Of course this can only be done if the running machine has one or more disk
drives. From the GUI, simply select the Disk Drive you want to change the disk
image for. This will open a Disk Drive window where you can specify what must
be in the drive: a disk image (select a disk image file, or create a new disk
image), a directory to be used as disk (see next section), a RAM disk
(temporary disk image in RAM), or nothing at all. As with ROM images,
IPS patches can be selected to be applied.
</p>

<p>
Disk images in compressed format ((g)zip, xsa) can be used as regular disk images,
but do note that they are read-only.
Note that in zipped disk images, the first file that is packed into the zip file
will be used as disk image.
</p>


<h5>Command line and console</h5>

<p>
To specify disk images on the command line, you can type:
</p>
<div class="commandline">openmsx relax.dsk</div>
<p>
for example. Or, if you use a disk image with a filename extension that is
unknown to openMSX:
</p>
<div class="commandline">openmsx -diska relax.di</div>

<p>
You can also change disks at run-time of course. Just type
</p>
<div class="commandline">
    <a class="external" href="commands.html#disk">diska</a> &lt;diskimage&gt;
</div>
<p>
in the <a class="internal" href="#console">console</a> to put the specified
disk image in drive A. To eject the disk from drive A, use:
</p>
<div class="commandline">
    <a class="external" href="commands.html#disk">diska</a> eject
</div>
<p>
Note that inserting another disk image automatically ejects the previous one.
</p>

<p>
To apply an IPS patch, provide the IPS filename like this:
</p>
<div class="commandline">openmsx SDSNAT1C.DSK -ips sdsnat1-eng.ips</div>
<p>
On the command line, the <code>-ips</code> option must immediately follow the disk image
it applies to. You can also use multiple <code>-ips</code> options if you
want to apply multiple patches.
</p>

<p>
You can also apply the patches when changing disks at run-time in the console.
Just type something like
</p>
<div class="commandline">
    <a class="external" href="commands.html#disk">diska</a> SDSNAT1C.DSK.gz
sdsnat1-eng.ips sd-cheat.ips
</div>
<p>
in the console to put the specified gzipped disk image SDSNAT1C.DSK.gz in drive
A, with both IPS patches applied.
</p>

<h4><a id="dirasdisk">5.2.2 Using Directories as Disks</a></h4>

<p>
The DirAsDsk feature permits you to use a directory on your host computer's
file system as a disk image for your emulated MSX.  Note that this has nothing
to do with harddisk emulation. It simply creates a
virtual disk structure in memory from the files that are in the directory
that you specified as if it were a disk image. So, on the command line: </p>
<div class="commandline">
    openmsx -diska .
</div>
<p>
will try to put all files of the current directory on a disk image in memory and
start openMSX with it. The actual data is still read from/written to the files
in your directory so that if you change the contents of the files, these changes
are immediately visible in the emulated MSX. This way you can for instance
edit source files with your favourite text editor but compile them immediately in
the emulated MSX.
</p>
<p>
Using the default value of the setting <a class="external"
href="commands.html#DirAsDSKmode">DirAsDSKmode</a> (full), all changes to the
directory on the host system <em>and</em> on the MSX system are performed, so
that they are immediately visible to the other side. If this is not the desired
behaviour, please <a class="external" href="commands.html#DirAsDSKmode">check
the documentation</a> of that setting.
</p>
<p>
<em>Be careful when writing to files from your emulated MSX.</em> In the
default 'full' mode, you can change/overwrite/delete/corrupt files on your host
system, if you made them accessible for the emulated MSX! Still, this is the
behaviour what most people want/expect and it's very useful if you know what
you are doing.
</p>
<p>
Note that MSX disks only have a limited capacity, typically 720kB. If the
host directory contains more data, then some host files will be ignored and
they will not appear in the virtual disk image.
</p>

<h4><a id="realdisks">5.2.3 Using Real Disks</a></h4>

<p>
We do not recommend using real disks (e.g. with a USB floppy drive)
with openMSX. There is no specific support for this.
</p>

<h4><a id="diskmanagement">5.2.4 Managing Disk Images</a></h4>

<p>
openMSX has a special command to perform file imports and
exports, with support for normal disk images, Sunrise IDE harddisk images with partitions (FAT12
only), and Nextor harddisk images with partitions (FAT12 and FAT16).
<p>
<p>
In the GUI, you can find this tool under <span class="menu-reference">Main menu
bar &rarr; Tools &rarr; Disk Manipulator</span>. This will open a big window,
which has many powerful options. On the left side you select the emulated
machine drive (any existing drive, or the "Virtual drive" which only exists in
memory). On the right side, you see the host directories with their file
content. Use the arrows in the middle to transfer files, the plus button on the
left side to create a new (hard) disk image and the directory button to browse
for a disk image to insert.
</p>

<p>
For the console commands that are behind this window, please see the separate manual called
<a class="external" href="diskmanipulator.html">Using diskmanipulator</a>.
</p>

<h3><a id="tape">5.3 Running Tape Software</a></h3>

<p>
First thing you need to be aware of: this can only be done on machines that
have a cassette port. Most do, but the MSX turboR machines do not, so tape
software cannot be used on these machines.
</p>

<p>
Cassette/tape image file formats that are supported are WAV files (raw digitized
recordings of real tapes) and CAS/TSX files. Differences are explained below.
</p>

<p>
In the GUI select <span class="menu-reference">Main menu bar &rarr; Media &rarr; Tape
Deck</span> to open the virtual cassette player control window, which allows
you to insert a cassette tape image.
</p>

<p>To insert a tape image from the <a class="internal" href="#console">console</a>, type:
</p>
<div class="commandline">
     <a class="external" href="commands.html#cassetteplayer">cassetteplayer</a> insert &lt;file&gt;.wav
</div>
<p>
Once inserted, in MSX Basic, type:
</p>
<div class="commandline">
     run"cas:"
</div>
<p>
(or another command to load the program on 'tape'.)
</p>

<p>
The cassetteplayer related commands/settings that are controlled in the tape deck window are:
</p>
<ul>
  <li><code>cassetteplayer rewind</code>, to rewind the tape</li>
  <li><code>cassetteplayer eject</code>, to eject the tape</li>
  <li><code>cassetteplayer new &lt;filename&gt;</code>, to create a new WAV cassette image to record to; also sets the cassette player in record mode</li>
  <li><code>cassetteplayer play</code>, to set the cassette player in play mode (when you've just recorded to the cassette)</li>
  <li><code>cassetteplayer record</code>, to set the cassette player in record mode, to append to existing cassette images (NOT IMPLEMENTED YET)</li>
  <li><code>set cassetteplayer_volume</code>, to set the volume of the cassette player sound (yeah, the screeching tape sounds!)</li>
</ul>

<p>
As you can see in this list, appending to existing cassette images (or
(partially) overwriting them) is not supported (yet). If you want to save
again, just insert a blank tape by using the <code>cassetteplayer new</code>
command again (or the Record button with the circle icon in the Tape Deck
window).
</p>

<h4><a id="cas">5.3.1 Using CAS and TSX files</a></h4>
<p>
You can also use the so-called CAS files and also TSX files. Use them exactly as you would use WAV
files, described in the previous section.
</p>

<p>
We don't support using CAS files by patching a BIOS natively, because it is not
really something we want: we prefer a more authentic emulation without hacks
like this.
So, the CAS (and also TSX) files are automatically converted to WAV files, internally. Note
that the loading time is drastically longer this way (but the <span class="menu-reference">Main menu bar &rarr; Settings &rarr; Speed &rarr; Go full speed when loading</span> <a class="external" href="commands.html#fullspeedwhenloading">setting</a>
will help a lot). On the other hand, you will be able to hear the cassette
sounds also with these file formats... Admit it, using cassettes with an MSX
without those characteristic sounds just wouldn't be the same.
</p>

<p>
To make it even more comfortable to run software from cassette tapes, check the <span class="menu-reference">Main menu bar &rarr; Media &rarr; Tape Deck &rarr; Controls &rarr; (try to) Auto Run</span> <a class="external" href="commands.html#autoruncassettes">setting</a>, that will attempt to
type the loading instruction for you after the MSX has started up.
</p>

<p>
Note that saving to existing cassette images is not possible; you can
only save to new cassette images in WAV format.
</p>

<h3><a id="harddisks">5.4 Emulating MSX Harddisks and CD-ROM</a></h3>

<p>
The Sunrise IDE interface was the first one to be emulated in openMSX, so by now it's thoroughly supported.
Later support for two types of SCSI interfaces was added:
the Gouda/Novaxis SCSI interface and the MEGA-SCSI, followed by support for
the MegaFlashROM SCC+ SD, the Carnivore 2, and the Beer IDE interfaces. Not all harddisk management tools may support these newer mass storage devices.
</p>

<p>
The extensions that enable this have a built in mass storage (harddisk, SD card, etc.) configuration, in the
form of a 100MB disk image. This is the default size: if the harddisk
image is not present, a file is created with this size. The image will end up
in your openMSX user
directory<code>/persistent/NAME/untitled1/IMAGENAME.dsk</code>, where NAME is
the name of the extension used and IMAGENAME is a name that is configured in
the extension's XML file (e.g. default <code>hd.dsk</code> for the Sunrise IDE).
</p>

<p>
When using these extensions for the first time, you have to treat them as if
they were real interfaces with a blank harddisk connected. How they should be initialised
depends on the type. We advise you read the manuals, the sections
below give some hints. The <code><a class="external"
href="diskmanipulator.html">diskmanipulator</a></code> may be helpful, as it
supports hard disk images with both Sunrise IDE and Nextor compatible partition
table formats.
</p>

<p>
For clarity's sake: since the emulation is done on a big disk image, data corruption of your PC's harddisk is impossible. You will need free
disk space for this image, however (default size: 100MB). In other words, you cannot use a normal PC harddisk as an MSX harddisk for these extensions.
</p>

<p>
The way to use files from your real PC harddisk on an emulated MSX,
is by using the DirAsDsk feature. See the <a class="internal"
href="#dirasdisk">DirAsDsk section</a> for more details.
</p>

<p>
In the GUI under <span class="menu-reference">Main menu bar &rarr; Media</span>
you can find entries like "Hard Disk A" or "CDROM Drive
A" if such devices are connected to the (IDE/SCSI/SD) extension in your
currently active machine. If wanted, you can also change the used image,
but note that media like harddisks require the machine
to be powered off first (see the <span class="menu-reference">Main menu
bar &rarr; Machine</span> menu for the <code><a class="external" href="commands.html#power">power</a></code>
setting).
</p>

<p>
To specify the harddisk image to be used on the command line, use the applicable command line option, e.g. for Sunrise IDE:
</p>
<div class="commandline">openmsx -ext ide -hda symbos.dsk</div>
<p>
This command gives you the ide extension with symbos.dsk as harddisk
image. You can also change the harddisk image at run time in the <a
class="internal" href="#console">console</a>, with a command similar to the <code><a class="external"
href="commands.html#disk">diska</a></code> command:
</p>
<div class="commandline">
    <a class="external" href="commands.html#hd">hda</a> &lt;diskimage&gt;
</div>

<p>Please read the following sections for details about the specific extensions.</p>

<h4><a id="ide">5.4.1 Sunrise IDE</a></h4>

<p>
The extension for this is called 'ide' (shown with the full name Sunrise
ATA-IDE in the extension selector). By default it has a harddisk connected to
the master port and a CD-ROM player connected to the slave port.
</p>

<p>
The 'ide' extension needs the BIOS that can be flashed into the Sunrise IDE
interface. It can be downloaded from the <a class="external"
href="http://www.msx.ch/sunformsx/download/dl-ide.html">Sunrise for MSX web
site</a>.
</p>

<p>
The initialisation of a Sunrise IDE harddisk is described in the text files
that come with the FDISK program for IDE, downloadable from the <a
class="external"
href="http://www.msx.ch/sunformsx/download/dl-ide.html">Sunrise for MSX web
site</a>. There are also <a class="external"
href="https://www.msx.org/forum/semi-msx-talk/emulation/how-get-sunrise-ide-working-openmsx">some</a>
<a class="external"
href="https://www.msx.org/forum/semi-msx-talk/emulation/openmsx-harddisk-emulation">threads</a>
on the MSX Resource Center forum that may give you valuable hints.
</p>
<p>
You can sidestep these procedures by using the <code><a class="external"
href="diskmanipulator.html">diskmanipulator</a></code> to create an initial hd
image complete with any desired files and subdirectories. For
instance to create a hard disk with 3 partitions of 32 megabyte on it, and have
each partition filled with files and subdirectories, proceed as follows:
</p>
<p>
Start openMSX with the ide extension, then type in the <a class="internal" href="#console">console</a>:
</p>
<div class="commandline">
set <a class="external" href="commands.html#power">power</a> off<br/>
<a class="external" href="diskmanipulator.html">diskmanipulator</a> <a class="external" href="diskmanipulator.html#create">create</a> /tmp/new-hd.dsk 32M 32M 32M<br/>
<a class="external" href="commands.html#hd">hda</a> /tmp/new-hd.dsk<br/>
<a class="external" href="diskmanipulator.html">diskmanipulator</a> <a class="external" href="diskmanipulator.html#import">import</a> hda1 /home/david/msxdostools/<br/>
<a class="external" href="diskmanipulator.html">diskmanipulator</a> <a class="external" href="diskmanipulator.html#import">import</a> hda2 /home/david/msxdemos/<br/>
<a class="external" href="diskmanipulator.html">diskmanipulator</a> <a class="external" href="diskmanipulator.html#import">import</a> hda3 /home/david/msxdrawings/<br/>
set <a class="external" href="commands.html#power">power</a> on
</div>

<p>
As announced above, there is (limited) support for CD-ROM with the 'ide'
extension. You can insert an ISO image in that virtual CD-ROM player with the
<code>-cda</code> command line option and change it at run time with the
<code><a class="external" href="commands.html#cd">cda</a></code> console
command, all similar to the aforementioned <code><a class="external"
href="commands.html#hd">hda</a></code> and <code><a class="external"
href="commands.html#disk">diska</a></code> commands and options.
</p>

<h4><a id="beeride">5.4.2 Beer IDE</a></h4>

<p>
The Beer IDE interface, as brought to us by SOLID, is emulated by openMSX, too.
This interface only offers a single device (no master and slave) and can only
handle up to 4 (version 1.9) or 5 (version 1.8) partitions of 32MB. On the
upside, it doesn't need MSX-DOS2, and thus it can run on any MSX (with
64kB RAM to run MSX-DOS). Emulation of this interface should be considered
experimental.
</p>

<p>
Usage is identical to using the Sunrise hard disk interface: you can use the
GUI, the <a class="external" href="commands.html#hd">hda</a> command and the
matching command line parameter <code>-hda</code> to control which image will
be used.
</p>

<p>
By default, the image is 128MB, so that it can fit 4 partitions of 32MB. Firmware
version 1.9RC1 is selected by default, because we could not get the 1.8
firmware to work: the MSXFDISK program didn't create partitions which actually
worked with the 1.8 firmware. If you want to experiment with it, you can change
the firmware to use by editing the extension file in
<code>share/extensions/Beer_IDE.xml</code>.
</p>

<p>
With the 1.9RC1 firmware, you can use <code><a class="external"
href="diskmanipulator.html">diskmanipulator</a></code> to create a hard disk
image and import from and export to them. To get started, partition the default
drive with <code>diskmanipulator partition hda -dos1 32M 32M 32M 32M</code>.
Then import MSX-DOS system files onto the first partition using
<code>diskmanipulator import hda1 &lt;host-path&gt;</code>, and now you should
be able to boot into MSX-DOS.
</p>

<p>
Unfortunately, the Beer IDE is hardly documented and the software is hard to
find. So, it's for experts only!
</p>

<h4><a id="scsi">5.4.3 SCSI devices</a></h4>

<p>
First of all: the SCSI emulation is experimental! There is a lot bigger chance
that you may lose data on your emulated harddisk images with SCSI than with
Sunrise IDE! When we tried it, everything seemed fine, but you have been warned.
</p>

<p>
The SCSI extensions (currently Gouda_SCSI, ESE_MEGA-SCSI and ESE_WAVE-SCSI)
have the default 100 MB harddisk image connected on target ID 1 and an (even
more experimental) LS-120 device (basically a harddisk like media that can be
changed/ejected when the power is on) on target ID 2.
</p>

<p>Specifying or changing hard disk images works the same as with IDE, see above.</p>

<p>
To change the disk image of the LS-120 device, use the <code>lsa</code> (LS
drive A) command, exactly the same as the <a class="external"
href="commands.html#hd">hda</a> command. Of course you do not need to have the
power turned off to do this, as this is the whole point of the LS-120 device.
You can also just eject it, with the <code>eject</code> subcommand. At the time
of writing there seems to be a bug when doing this: the device isn't listed in
the device list if there is no media inserted. It is currently not possible to specify an
LS-120 device on the command line.
</p>

<p>
Initialisation for the ESE SCSI devices needs tools like <code>MGINST</code>,
which can be found on <a class="external"
href="http://www.msxnet.org/gtinter/nogame-e.htm">Takamichi's web site</a>.
They include small manuals in English. This manual is not the place to explain
the procedure, but the idea is as follows. First, install the MSX-DOS 2 kernel
in the SRAM of the device, using the <code>MGINST</code> program (you might
want to use <code>KSAVER</code> first to save the kernel of your DOS 2
cartridge). After this, the MSX will boot from the SRAM disk. Use the
<code>SFORM-1</code> (for MSX-DOS) or the <code>SFORM-2</code> (for MSX-DOS 2)
to format the drive (use a physical format, for now). Use <code>ESET</code> to
assign drive letters to partitions.
</p>

<p>
For the Gouda (Novaxis) SCSI interface, you need the Novaxis ROM, see also <a
class="external" href="http://msx.hansotten.com/index.php?page=msxscsi">Hans
Otten's Page</a> or <a class="external"
href="http://faq.msxnet.org/scsi.html">The Ultimate MSX FAQ</a>. Those sites
also contain manuals for the Novaxis ROM. Initialisation is done with the
<code>NFDISK</code> utility, which can be found on <a class="external"
href="https://web.archive.org/web/20200315110709/http://members.chello.nl/m.delorme/">Marcel Delorme's site</a> (archived).
</p>

<h4><a id="sd">5.4.4 MegaFlashROM SCC+ SD</a></h4>

<p>
Currently there is only one SD interface emulated: the MegaFlashROM SCC+ SD.
All features of this cartridge are emulated in the sense that all software currently
working with it, runs on openMSX too. It is not emulated accurately
enough to rely on it for development.
</p>

<p>
The SD card slots appear in the openMSX user interface as "Hard Disk A/B" and
hot plugging is not supported. So, it shows up almost identically to the
Sunrise IDE interface.
</p>

<p>
The difference compared to a real MegaFlashROM SCC+ SD, is that the extension does not
come with anything flashed on the flash ROM by default. There are two ways to
overcome that. The first one is to download the preflashed ROM content (for URL
see below) and install it into your systemroms folder, like any usual system
ROM. This only works if you use the extension for the first time, unless you
manually delete the persistent file for the flash ROM chip (typically in your
openMSX user
directory<code>/persistent/MegaFlashROM_SCC+_SD/untitled1/megaflashromsccplussd.sram</code>).
Only if no such file is found, openMSX will load the content of that ROM file
into the flash ROM of the MegaFlashROM SCC+ SD. The second way is manually
flashing things like Nextor, the rescue menu and the ROM disk. This is all
described in the manual (see at the end of this section) of the MegaFlashROM
SCC+ SD, because on a real device you may also need to do this.
</p>

<p>
Once you achieved this, usage is again identical to using the Sunrise hard disk
interface, so in the console you can use the <a class="external"
href="commands.html#hd">hda/hdb</a> commands and the matching command line
parameters <code>-hda</code> and <code>-hdb</code> to control which image will
be used for the first and second SD card.
</p>

<p>
Currently, by default, the first SD card is 8MB and the 2nd SD card is 100MB in
size. You can change these defaults by editing the extension file in
<code>share/extensions/MegaFlashROM_SCC+_SD.xml</code>. For formatting and
managing the SD cards, please refer to its manual and tools on the Flash part
of the <a class="external" href="http://www.msxcartridgeshop.com/">MSX
Cartridge Shop</a>. It also provides the ROM file with the initial content of
the flash ROM as it is shipped on real MegaFlashROM SCC+ SD cartridges.
</p>

<p>
To get files on the SD cards, you can use <code><a class="external"
href="diskmanipulator.html">diskmanipulator</a></code> with the
<code>-nextor</code> option to partition and to import files, similar to what
is explained above <a class="internal" href="#ide">in the Sunrise IDE
section</a>.
</p>

<h3><a id="laserdisc">5.5 Running Laserdisc software</a></h3>

<p>
In order to run Laserdisc software, you need to have this optional feature
compiled into your openMSX binary. Laserdisc is only supported by the Pioneer
PX-7 or the Pioneer PX-V60 machines, which have special hardware to control the
laserdisc player.
</p>


<p>
The Laserdisc image can be selected under <span class="menu-reference">Main
menu bar &rarr; Media &rarr; LaserDisc Player</span> or in the <a
class="internal" href="#console">console</a>, type <code><a class="external" href="commands.html#laserdiscplayer">laserdiscplayer</a> insert &lt;file&gt;.ogv</code>
</p>
<p>
to insert a Laserdisc (image) into the Laserdisc player.
By default, the Laserdisc will be loaded automatically. If the
<a class="external" href="commands.html#autorunlaserdisc">autorunlaserdisc</a>
setting is off, then you will have to take a few steps yourself.
</p>

<p>
After booting the MSX, choose option 1 when asked if you want to run P-BASIC
(Palcom-BASIC). In MSX-BASIC, type:
</p>

<div class="commandline">
     call ld
</div>
<p>
to load and run the Laserdisc program.
</p>

<p>
The program is encoded on the right audio channel, which will not be audible.
With <code>set <a class="external"
href="commands.html#fullspeedwhenloading">fullspeedwhenloading</a> on</code>,
openMSX runs at maximum speed whenever the Laserdisc is seeking or loading a
program.
</p>

<h2><a id="input">6. Input Devices</a></h2>

<h3><a id="keyboard">6.1 Keyboard</a></h3>

<a id="keymapping"><!--backwards compat--></a>
<h4><a id="msxkeymapping">6.1.1 MSX Key Mapping</a></h4>

<p>
The special MSX keys are mapped as follows, the first column for PCs (running
Windows, Linux or BSD), the second column for Apple Macintosh computers:
</p>

<table>
  <tr> <th>MSX key</th>              <th>key (PC)</th> <th>key (Mac)</th>  </tr>
  <tr> <td>CTRL key</td>             <td>L-CTRL</td>   <td>L-CTRL</td>     </tr>
  <tr> <td><a class="external" href="commands.html#kbd_deadkey1_host_key">dead (accents) key</a></td><td>R-CTRL</td>    <td>R-CTRL</td> </tr>
  <tr> <td>GRAPH key</td>            <td>L-ALT</td>    <td>L-ALT</td>      </tr>
  <tr> <td><a class="external" href="commands.html#kbd_code_kana_host_key">CODE/KANA key</a></td><td>R-ALT</td>     <td>R-ALT</td>      </tr>
  <tr> <td>取消 ('cancel') key</td>  <td>L-Windows</td><td></td>           </tr>
  <tr> <td>実行 ('execute') key</td> <td>R-Windows</td><td></td>           </tr>
  <tr> <td>SELECT key</td>           <td>F7</td>       <td>F7</td>         </tr>
  <tr> <td>STOP key</td>             <td>F8</td>       <td>F8</td>         </tr>
  <tr> <td>INS key</td>              <td>Insert</td>   <td>Cmd+I</td>      </tr>
</table>

<h4><a id="cvkeymapping">6.1.2 ColecoVision Key Mapping</a></h4>

<p>The ColecoVision controllers are mapped as follows:</p>

<table>
  <tr> <th>direction/key</th>  <th>player 1</th>                <th>player 2</th>    </tr>
  <tr> <td>up</td>             <td>cursor up</td>               <td>W</td>           </tr>
  <tr> <td>down</td>           <td>cursor down</td>             <td>S</td>           </tr>
  <tr> <td>left</td>           <td>cursor left</td>             <td>A</td>           </tr>
  <tr> <td>right</td>          <td>cursor right</td>            <td>D</td>           </tr>
  <tr> <td>fire left</td>      <td>space, R-CTRL</td>           <td>L-CTRL</td>      </tr>
  <tr> <td>fire right</td>     <td>L-ALT, R-ALT, R-SHIFT</td>   <td>L-SHIFT</td>     </tr>
  <tr> <td>1</td>              <td>1, numpad 1</td>             <td>R</td>           </tr>
  <tr> <td>2</td>              <td>2, numpad 2</td>             <td>T</td>           </tr>
  <tr> <td>3</td>              <td>3, numpad 3</td>             <td>Y</td>           </tr>
  <tr> <td>4</td>              <td>4, numpad 4</td>             <td>F</td>           </tr>
  <tr> <td>5</td>              <td>5, numpad 5</td>             <td>G</td>           </tr>
  <tr> <td>6</td>              <td>6, numpad 6</td>             <td>H</td>           </tr>
  <tr> <td>7</td>              <td>7, numpad 7</td>             <td>V</td>           </tr>
  <tr> <td>8</td>              <td>8, numpad 8</td>             <td>B</td>           </tr>
  <tr> <td>9</td>              <td>9, numpad 9</td>             <td>N</td>           </tr>
  <tr> <td>0</td>              <td>0, numpad 0</td>             <td>U</td>           </tr>
  <tr> <td>*</td>              <td>-, numpad *, numpad -</td>   <td>J</td>           </tr>
  <tr> <td>#</td>              <td>=, numpad /, numpad +</td>   <td>M</td>           </tr>
</table>

<p>
Host joysticks can also be used for directions and the fire buttons, but the
keys from the telephone-style keypad can only be entered via the host keyboard.
</p>

<h4><a id="emukeymapping">6.1.3 Emulator Functions Key Mapping</a></h4>

<p>
The mapping of the keys for emulator functions is fully customisable using the
<a class="external" href="commands.html#bind"><code>bind</code></a> command in
the <a class="internal" href="#console">console</a>. Your customised key
bindings are saved together with the settings. This subsection lists the
default key mapping.
</p>

<table>
  <tr> <th>keys (PC)</th>  <th>keys (Mac)</th>         <th>function</th> </tr>
  <tr> <td>Pause</td>      <td>Cmd+P (Pause)</td>      <td>Pause emulation</td> </tr>
  <tr> <td>ALT+F4</td>     <td>Cmd+Q (Quit)</td>       <td>Quit openMSX</td> </tr>
  <tr> <td>CTRL+Pause (Break)</td> <td></td>           <td>Quit openMSX (not in Windows)</td> </tr>
  <tr> <td>PrtScr</td>     <td>Cmd+D (Dump)</td>       <td>Save current screen to a file (<a class="external" href="commands.html#screenshot">screen shot</a>)</td> </tr>
  <tr> <td>PageUp</td>         <td>PageUp</td>   <td>Go 1 second back in time, using the <a class="external" href="commands.html#reverse">reverse</a> feature</td> </tr>
  <tr> <td>PageDown</td>         <td>PageDown</td>   <td>Go 1 second forward in time, using the <a class="external" href="commands.html#reverse">reverse</a> feature</td> </tr>
  <tr> <td>F9</td>         <td>Cmd+T (Fastforward)</td>   <td>Toggle <a class="external" href="commands.html#fastforward">fastforward</a> mode (normal vs fastforward speed)</td> </tr>
  <tr> <td>F10</td>        <td>Cmd+L (consoLe)</td>    <td>Toggle <a class="external" href="commands.html#console">console</a> display</td> </tr>
  <tr> <td>F11 or ALT+Enter</td> <td>Cmd+F (Full)</td> <td>Toggle <a class="external" href="commands.html#fullscreen">full screen</a> mode</td> </tr>
  <tr> <td>F12</td>        <td>Cmd+U (mUte)</td>       <td>Toggle <a class="external" href="commands.html#mute">audio mute</a></td> </tr>
  <tr> <td>ALT+F7</td>     <td>Cmd+R (Restore)</td>    <td>Quick <a class="external" href="commands.html#savestate">loadstate</a> (from 'quicksave' slot)</td> </tr>
  <tr> <td>ALT+F8</td>     <td>Cmd+S (Save)</td>       <td>Quick <a class="external" href="commands.html#savestate">savestate</a> (to 'quicksave' slot)</td> </tr>
  <tr> <td>CTRL+Win+C</td>     <td>Cmd+C (Copy)</td>       <td>Copy screen's text content to clipboard</td> </tr>
  <tr> <td>CTRL+Win+V</td>     <td>Cmd+V (paste)</td>       <td>Type the text from the clipboard into the MSX</td> </tr>
</table>
<!--
<p class="todo">
Make the table look better by using cellpadding stuff in the css.
</p>-->

<p>
Note that Mac users must use <code>GUI</code> as a modifier for the Command
(Apple logo) key. On PC's use <code>GUI</code> for the Windows key.
</p>

<p>
Please note that openMSX is currently intended to be mouse controlled.
Some parts of the GUI can also be controlled via keyboard, but this has not
been optimized at all for now. Control via gamepad is currently disabled (this
might change in a future version).
</p>

<h4><a id="keyboardlayouts">6.1.4 Keyboard Layouts</a></h4>

<p>
This section is about how host computer keyboard layouts are mapped to
MSX keyboard layouts. This is mostly interesting if those differ
(a lot). For example, you have a US-English keyboard on your PC and you are
emulating a Japanese MSX computer. Or, you have a Japanese Mac and you are
emulating a Spanish MSX computer.
</p>

<p>
There are facilities to make this as smooth as possible,
so that you can use your own keyboard for any kind of MSX with as little
surprises as possible. The trick is the new character-based <a class="external"
href="commands.html#kbd_mapping_mode">mapping mode</a>, which tries to convert
any character you enter with your host computer's keyboard to an MSX key press.
For this feature, all MSX hardware configuration files now have information
about their keyboard layout. Anyway, this mapping mode is enabled by default,
so you don't have to do anything to make this work!
</p>

<p>
However, there are always some pesky details. For those details we refer to the
documentation of other keyboard settings, where they are explained in full
detail: <a class="external" href="commands.html#kbd_mapping_mode">mapping
mode</a> (as mentioned before), <a class="external"
href="commands.html#kbd_numkeypad_always_enabled">kbd_numkeypad_always_enabled</a>
(use numerical keypad even when your MSX doesn't have one), <a class="external"
href="commands.html#kbd_code_kana_host_key">kbd_code_kana_host_key</a> (specify
an alternative host key for CODE/KANA) and <a class="external"
href="commands.html#kbd_numkeypad_enter_key">kbd_numkeypad_enter_key</a>
(specifies mapping of the ENTER key of the keypad).
</p>

<p>
You can find the mapping mode setting in <span class="menu-reference">Main menu
bar &rarr; Settings &rarr; Input &rarr; Keyboard mapping mode</span>.
</p>

<h3><a id="joystick">6.2 Joystick</a></h3>

<p>
If you have a controller or joystick connected to your PC, you can map its
input to one of the emulated MSX joystick (like) devices, internally called <code>msxjoystick1</code>,
<code>msxjoystick2</code>, <code>joymega1</code> and <code>joymega2</code>.
</p>

<p>
See the <a class="internal" href="#plug">earlier section about plugging
devices</a> on how to connect these devices to your emulated machine.
</p>

<p>
The mapping of your host devices (host controllers, joysticks or keyboard) to
these 4 emulated MSX joysticks is fully configurable. The easiest way is to use
the GUI menu for that under <span class="menu-reference">Main menu bar &rarr;
Settings &rarr; Input &rarr; Configure MSX joysticks</span>. You can also do it
in the console with the  <a class="external"
href="commands.html#msxjoystickN_config">msxjoystick&lt;n&gt;_config/joymega&lt;n&gt;_config</a>
settings.
</p>

<p>
Most modern joysticks have more buttons than the 2 buttons that are defined by
the MSX standard. Therefore a lot of games use extra keys on the keyboard for
extra functionality. For instance, almost all Konami games use F1 to pause
the game. You can assign this extra functionality to your joystick by using the
<code><a class="external" href="commands.html#bind">bind</a></code> command. As
an example here is how to map button 4 of the first joystick to the F1-key,
button 5 to F2, ...
</p>
<div class="commandline">
  bind "joy1 button4 down" "keymatrixdown 6 0x20"<br/>
  bind "joy1 button4 up" "keymatrixup 6 0x20"<br/>
  bind "joy1 button5 down" "keymatrixdown 6 0x40"<br/>
  bind "joy1 button5 up" "keymatrixup 6 0x40"<br/>
  bind "joy1 button6 down" "keymatrixdown 6 0x80"<br/>
  bind "joy1 button6 up" "keymatrixup 6 0x80"<br/>
  bind "joy1 button7 down" "keymatrixdown 7 0x01"<br/>
  bind "joy1 button7 up" "keymatrixup 7 0x01"<br/>
  bind "joy1 button8 down" "keymatrixdown 7 0x02"<br/>
  bind "joy1 button8 up" "keymatrixup 7 0x02"<br/>
</div>
<p>
For a more detailed explanation of this command see the <a class="external"
href="commands.html#bind">Console Command Reference</a>. Please note that
unfortunately, such mappings are not configurable via the GUI menu.
</p>
<h3><a id="mouse">6.3 Mouse</a></h3>

<p>
To connect a mouse, you can also use the <span class="menu-reference">Main menu
bar &rarr; Connectors</span> menu or the <code><a
class="external" href="commands.html#plugunplug">plug</a></code> command: <code>plug joyporta mouse</code>
will connect a mouse to joystick port A. If you want the joystick emulation
feature that some mice (like the Philips SBC-3810 and the Sony MOS-1) have,
keep the left mouse key pressed when plugging it in, just as on a real MSX.
</p>

<p>
If you are using openMSX in windowed mode, it might be tricky to use the mouse.
The setting: <code>set <a
class="external" href="commands.html#grabinput">grabinput</a> on</code>
makes sure all input goes to openMSX. Your cursor cannot leave the openMSX
window with this setting. Just turn it back to off, if you want to disable this
again. If you only want to escape the window briefly, use this command:
<code><a class="external"
href="commands.html#escape_grab">escape_grab</a></code>. It permits you to
leave the window, but the next time you enter it, the cursor is grabbed again.
It might be a good idea to bind this command to a key, using the <code><a
class="external" href="commands.html#bind">bind</a></code> command, which is
mentioned above.
</p>

<h3><a id="arkanoidpad">6.4 Arkanoid Pad</a></h3>

<p>
The Arkanoid games by Taito both have support for a special Arkanoid game pad,
with a classical rotary knob to control the position of the bat. This device
is emulated as well and can be controlled by the mouse. Plug it via the GUI
<span class="menu-reference">Main menu bar &rarr; Connector</span> menu or in
the console with <code><a class="external" href="commands.html#plugunplug">plug</a> joyporta arkanoidpad
</code>.
</p>

<h3><a id="trackball">6.5 Trackball</a></h3>

<p>
Some MSX trackballs like the HAL CAT and the Sony HB-G7B seem to have identical hardware
and are also emulated by openMSX, again using the mouse to control it. In MSX
software, the trackball is mostly supported in port B only. Using the console
you can use therefore <code><a class="external"
href="commands.html#plugunplug">plug</a> joyportb trackball</code>.
</p>

<p>
Quite some HAL programs have support for it, e.g. Hole in One, Eddy II, Music
Studio G7, Space Trouble and Super Billiards. The test program provided in the
Sony HB-G7B service manual also works fine, of course.
</p>

<h3><a id="touchpad">6.6 Touchpad</a></h3>

<p>
Some MSX touch pads like the Philips NMS 1150 Graphic Tablet are also emulated
by openMSX, again using the mouse to control it (where mouse button 1
corresponds to touch or no touch and mouse button 2 to the button on the pen of
the touch pad). Also the touch pad is mostly supported in port B only, so the
console command is <code><a class="external" href="commands.html#plugunplug">plug</a> joyportb touchpad</code>
</p>

<p>
This device is mostly supported by the Philips drawing programs Designer,
Designer Plus and Video Graphics (all in port B) and by Pioneer MSX Video Art
(port A).
</p>

<p>
Note that the whole openMSX window will function as the surface of the touch
pad. This may not align with the actual pixels of the screen in that window,
see the <a class="external"
href="commands.html#touchpad_transform_matrix">touchpad_transform_matrix</a>
setting for how to adjust this.
</p>

<h3><a id="magickey">6.7 Magic Key</a></h3>

<p>
Sony made a small dongle for game testers to cheat within the games. The games
that have support for it will check if the UP and DOWN keys are pressed. The
magic key is supported by these games in port B only (console: <code><a
class="external" href="commands.html#plugunplug">plug</a> joyportb
magic-key</code>.
</p>


<p>
Known games that can use this Magic Key are:
</p>
<dl>
<dt>Family Boxing (Sony)</dt>
<dd>Press the Graph key on the title screen to enter the secret menu</dd>
<dt>Jansei (Sony)</dt>
<dd>You can set the characteristics of the enemy by moving the cursor to
"Actual Battle" on the menu screen and pressing ESC and SELECT.</dd>
<dt>Gall Force - Defense of Chaos (Sony)</dt>
<dd>A new menu item will appear on the home screen</dd>
</dl>

<h3><a id="ninjatap">6.8 Ninja Tap</a></h3>

<p>
The Ninja Tap (忍者タップ) is an adapter designed by Knight's chamber and
sold in Japan by PCCM. This adapter allows to use up to 4 joysticks by port.
Plug it via the GUI or with the console using <code><a class="external"
href="commands.html#plugunplug">plug</a> joyporta ninjatap</code>.
</p>


<h3><a id="tetris2dongle">6.9 Tetris II Special Edition dongle</a></h3>

<p>
Tetris 2 Special Edition from R.A.M., an Italian MSX group, needs the dongle in
port B too start the game. So, on the console use <code><a class="external"
href="commands.html#plugunplug">plug</a> joyportb tetris2-protection
</code>
</p>

<h3><a id="msxpaddle">6.10 MSX Paddle</a></h3>

<p>
The MSX paddle controller is a quite simple device, but there are not so many
commercial implementations for MSX. The Yamaha MMP-01 is a music pad that is
known to use this protocol to transmit its coordinates. Plug it in the console
as follows: <code><a class="external" href="commands.html#plugunplug">plug</a>
joyporta paddle</code>.
</p>

<h3><a id="circuitdesignerrddongle">6.11 Circuit Designer dongle</a></h3>

<p>
Circuit Designer dongle from The Falcon, needs the dongle in port B to start
the program, so in the console type: <code><a class="external"
href="commands.html#plugunplug">plug</a> joyportb circuit-designer-rd-dongle
</code>.
</p>

<h2><a id="video">7. Video</a></h2>

<p>
openMSX uses the OpenGL graphics library for all post processing (hence
the PP in SDLGL-PP, which is the name of the "renderer", the software component that generates
the graphical part of the emulation, the MSX 'screen'). This includes
scalers and other effects, but also the GUI...
Because of all this, openMSX runs best with a hardware accelerated
OpenGL library. See the Setup Guide for
<a class="external" href="setup.html#opengl">OpenGL performance tips</a>.
So, again, be aware that openMSX requires both your video
card and video driver to support at least OpenGL 2.0. Sometimes you need to
upgrade your driver to make it work. If your videocard or driver don't support
OpenGL 2.0, openMSX will not start up and report an error.
</p>

<p>
Most video related settings can be found under the <span
class="menu-reference">Main menu bar &rarr; Settings &rarr; Video</span> menu.
The rest of this section describes more details about the settings you can find
there. For instance, for full screen mode, there is a checkbox in that menu,
which maps to the <code><a class="external"
href="commands.html#fullscreen">fullscreen</a></code> setting.
</p>

<h3><a id="scalers">7.1 Scalers</a></h3>

<p>
Most MSX screen modes are only 256&times;212 pixels big. This is quite small
for today's PC screen resolutions. That's why you have the possibility to
scale up the image. There are currently three possible scaling factors: 2, 3
and 4. If you select 2, all MSX pixels are mapped to a 640&times;480 pixels PC
window, for 3 to a 960&times;720 pixel window and for 4 to the obvious
1280&times;960 window. The setting which determines this is called <code><a
class="external" href="commands.html#scale_factor">scale_factor</a></code>. In
general, the higher the factor, the better the output image is.
</p>

<p>
There are also a number of scaling algorithms (setting <code><a class="external"
href="commands.html#scale_algorithm">scale_algorithm</a></code>) that can be
set. The scaling algorithm determines how exactly the mapping is done between
the MSX input screen and the PC output screen. As we render more pixels than
the normally visible MSX pixels, this allows for extra possibilities in the algorithms, like
deinterlacing and adding scanlines, blur, anti-aliasing (rounding of blocky
patters like stair cases) or even a Trinitron-like TV effect.
</p>

<p>
openMSX contains the following scaling algorithms:
</p>

<dl>

<dt>simple</dt>
<dd>
This algorithm simply expands each MSX pixel to a square of
(scale_factor)&times;(scale_factor) PC pixels.
This is the default scaler and can be tuned to look like most CRT screens.
The image looks blocky, especially diagonal edges, but it does support
scanlines and blur.
</dd>

<dt><a class="external" href="http://scale2x.sourceforge.net/">ScaleNx</a></dt>
<dd>
This scaler algorithm smoothes edges by using only original colors, so it will
not give any blur. It is fast and its image is less blocky than that of the
simple scaler. However, all corners are rounded, which does not look good on
all graphics. This scaler has not been properly implemented for scaling factors
of 4.
</dd>


<dt><a class="external" href="http://en.wikipedia.org/wiki/Hqx">hq</a></dt>
<dd>
This algorithm does a good job on most graphics; it avoids excessive blurring
and it keeps corners sharp.
On some graphics, it does not identify edges correctly, making those edges
blocky instead of smooth.
Especially with high scaling factors, it can give a very smooth looking image.
</dd>

<dt>hqlite</dt>
<dd>
This is a variant of hq: the resulting image is close to hq, but it is
calculated a lot faster.
</dd>

<dt>RGBTriplet</dt>
<dd>
This algorithm only works as intended when a scaling factor of 3 is used. Also,
it only works well for MSX screen modes of 256&times;212, which includes most
games. The idea of the algorithm is that each input pixel is mapped on a
triplet of pixels which represent the R(ed), G(reen) and B(lue) components of
the input pixel. This arrangement of RGB components is also used in the <a
class="external" href="http://en.wikipedia.org/wiki/Aperture_grille">Aperture
Grille</a> CRT's, also known as Trinitron and the modern TFT screens. You can
control the effect with the <code><a class="external"
href="commands.html#blur">blur</a></code> setting. This algorithm also includes
scan lines.
</dd>

<dt>TV</dt>
<dd>
This algorithm tries to emulate the fact that on a CRT brighter pixels look
bigger than darker pixels. It has some minor flaws, but is already developed
far enough to make it available for you to try out.
</dd>

</dl>

<p>
A small (somewhat outdated) demonstration of some of the algorithms can be
found on <a class="external" href="http://openmsx.org/">the openMSX web
site</a>.
</p>

<h3><a id="gamma">7.2 Gamma Correction</a></h3>

<p>
PC monitors can have different gamma values than MSX monitors.
To compensate for this, openMSX has a gamma correction feature.
It is controlled by the <code><a class="external"
href="commands.html#gamma">gamma</a></code> setting.
A value of 1.0 disables gamma correction; a lower value makes the image darker;
a higher value makes it brighter.
</p>

<p>
If you want to know what gamma correction really means, read <a
class="external" href="http://www.bberger.net/rwb/gamma.html">this page about
monitor gamma</a>.
The gamma correction value you can set in openMSX should be the gamma of your
PC screen divided by the gamma of the MSX screen.
I measured the gamma of my PC screen (TFT) at 2.0 and the gamma of my MSX
monitor at 2.5. That puts the gamma correction at 2.0 / 2.5 = 0.8.
So if I enter that value, the openMSX image will have comparable brightness to
the MSX image.
However, 0.8 is not the value I'm actually using: I prefer a brighter image
than my MSX monitor, so I chose to use a gamma correction of 1.1.
</p>

<h3><a id="videoeffects">7.3 Special Effects</a></h3>

<p>
openMSX contains a couple of special effects settings that can be applied to
the video output:
</p>

<dl>

<dt><code><a class="external" href="commands.html#deinterlace">deinterlace</a></code></dt>
<dd>
Interlacing is a technique to double the vertical resolution by splitting the
image into two frames: the first frame displays the even lines, the second
frame the odd lines.
The after glow on a TV and some processes in the human brain combine both
frames into a single image. However, this process is not perfect and you can
notice flickering, especially on horizontal lines.
The deinterlace feature combines the even and the odd frames into a single
output frame, thus eliminating the flicker.
The <code><a class="external"
href="commands.html#deinterlace">deinterlace</a></code> setting controls this
feature:
it can be on (enabled) or off (disabled); it is enabled by default.
</dd>

<dt><code><a class="external" href="commands.html#deflicker">deflicker</a></code></dt>
<dd>
This filter detects pixels that alternate each frame between two different
colors and replaces those alternations with the average color. Such
'flickering' pixels can occur in software that rapidly changes between colors
to create the illusion of a wider color palette. It can also occur because of
'sprite flickering'. This setting is disabled by default because there aren't
that many situations where it really improves video quality, but it does have
a performance cost.
</dd>

<dt><code><a class="external" href="commands.html#scanline">scanline</a></code></dt>
<dd>
On TV's and MSX monitors, you can see a small black space in between the
display lines, especially when using NTSC.
The scanlines feature simulates this by drawing some lines a bit darker.
This feature is disabled when a scaling algorithm other than
<code>simple</code>, <code>tv</code> or <code>RGBTriplet</code> is used.
</dd>

<dt><code><a class="external" href="commands.html#blur">blur</a></code></dt>
<dd>
TV's and MSX monitors are less sharp than PC monitors:
neighbouring pixels tend to blur into each other.
The blur feature simulates this by interpolating neighbouring pixels.
The <code><a class="external" href="commands.html#blur">blur</a></code>
settings control this:
0 means no blur (completely sharp), 50 means some blur (like a monitor),
100 means maximum blur (like a TV).
All other values between 0 and 100 are also possible of course.
This feature is disabled when a scaling algorithm other than
<code>simple</code> or <code>RGBTriplet</code> is used.
</dd>

<dt>after glow (<code><a class="external" href="commands.html#glow">glow</a></code>)</dt>
<dd>
The after glow feature blends each frame with the previous one.
This results in moving objects leaving a trail (motion blur).
The <code><a class="external" href="commands.html#glow">glow</a></code> setting
controls the amount of after glow:
0 means no after glow, 100 means maximum after glow.
</dd>

<dt><code><a class="external" href="commands.html#noise">noise</a></code></dt>
<dd>
This setting controls the amount of pixel noise on the screen.
The <code><a class="external" href="commands.html#noise">noise</a></code>
setting controls the amount:
0 means no noise, 100 means maximum noise. The value is actually the deviation
of the colour of the original pixel and non-integer values are also possible.
</dd>

<dt>display deformation (<code><a class="external"
href="commands.html#display_deform">display_deform</a></code>)</dt>
<dd>
This feature makes it possible to change the shape of the MSX screen. Here are the possibilities:
 <ul>
  <li><code>normal</code>: no deformation (default)</li>
  <li><code>3d</code>: emulates a 3D view on an arcade cabinet's screen</li>
 </ul>
</dd>

</dl>

<h3><a id="accuracy">7.4 Accuracy</a></h3>

<p>
An advanced setting (which you can find under <span class="menu-reference">Main
menu bar &rarr; Settings &rarr; Video &rarr; Advanced (for debugging)</span>
(the <code><a class="external"
href="commands.html#accuracy">accuracy</a></code> setting) controls how often
the renderer is synchronised with the MSX video processor (VDP).
There are three options:
</p>

<dl>
<dt>screen</dt>
<dd>
Synchronise once per screen (frame).
Good enough for most MSX1 software, but will break most raster effects.
</dd>

<dt>line</dt>
<dd>
Synchronise at the start of a line.
This is good enough for most software.
This setting hides imperfections in raster effects,
which could be considered a useful feature.
</dd>

<dt>pixel</dt>
<dd>
Synchronise at the exact pixel where a change occurs.
This is the most realistic setting and therefore set as the default.
To see demos like Unknown Reality (scope part) and Verti correctly,
you should use this setting.
Also, you will see any imperfections in raster effects
just like they occur on a real MSX.
</dd>

</dl>

<h3><a id="gfx9000">7.5 GFX9000/Video 9000</a></h3>

<p>
openMSX has GFX9000 emulation. As there isn't that much software for it
available, it is not as complete, functional and optimized as the video
emulation of the classical MSX chips.
Despite of all this, most existing GFX9000 software runs pretty well, so we
found it worth sharing with you anyway.
</p>

<p>
The real GFX9000 has an external video connector to which you can connect a
second monitor. We never took the trouble to
emulate a second monitor, however, so to see the GFX9000 in action, you need to switch the
videosource setting, which mimics a so-called SCART-switch in the real
world: <code>set
<a class="external" href="commands.html#videosource">videosource</a> GFX9000</code>.
This setting is only available when there are actually multiple video sources
available. In the GUI you can find it under <span
class="menu-reference">Main menu bar &rarr; Settings &rarr; Video &rarr; Video
source to display</span>.
</p>

<p>
Alternatively, instead of the GFX9000 extension, you could use the
Video9000 extension (also built in in several Boosted MSX machine
configurations). The Video 9000 hardware has the possibility to superimpose the
GFX9000 video on top of the V99xx video (and this is practically the only
feature of the Video 9000 that is currently implemented). Software that is
Video 9000 aware, will tell the Video 9000 to show the GFX9000 if something
interesting is to be seen on the GFX9000 video output. So, for such software,
you do not have to switch video sources if you simply use the Video9000
video source. When a Video 9000 is present in the currently running MSX
configuration, the Video9000 video source will be selected by default, to make
use of this superimpose feature. For programs not aware of Video 9000, you will
still have to switch video sources manually, just like on a real system.
</p>

<p>
To get your normal MSX screen back, set the setting back to MSX. If you want to
toggle between them with a hotkey, it might be useful to bind a key for it. E.g.: <code><a
class="external" href="commands.html#bind">bind</a> F6 cycle <a
class="external" href="commands.html#videosource">videosource</a></code>.<br/>
<code><a class="external" href="commands.html#cycle">cycle</a></code> is a Tcl
command that cycles through the options of the setting in the parameter.
</p>

<h3><a id="recording">7.6 Video Recording</a></h3>

<p>
The video recorder enables you to record the audio and video rendered by
openMSX to an AVI file. The output video is in 320&times;240 resolution by
default, at 640&times;480 when using the <code>-doublesize</code> flag and at
960&times;720 when using the <code>-triplesize</code> flag. The video is
compressed with the ZMBV codec, a fast lossless compression algorithm that
works very well on 2D computer generated images. The <a class="external"
href="faq.html#codec">FAQ</a> contains more information about this codec. The
audio is uncompressed.
</p>
<p>
The recorded AVI file will not suffer from any hiccups, even if the emulation
ran too slow when you recorded it. The current video source (see previous
section) is recorded and the sound is recorded with the current <code><a
class="external" href="commands.html#frequency">frequency</a></code> setting.
If you change the <code><a class="external"
href="commands.html#frequency">frequency</a></code> setting during recording,
or, more importantly, if the software changes from PAL (50 Hz) to NTSC (60 Hz)
during recording, the video will get out of sync with the audio. Most of the <a
class="internal" href="#videoeffects">special effects</a> will not be recorded.
</p>

<p>
If any stereo sound devices are present or any sound device has an off-center
balance, the recording will be made in stereo, otherwise it will be mono. If
a recording is made in mono and then a stereo sound device is added, you'll
receive a warning that stereo sound has been detected and that the two
channels will be mixed down to mono. You can prevent this from happening by
using the <code>-stereo</code> option to force a stereo recording even if
no stereo devices are present at the time you enter the command. You can also
force a mono recording with <code>-mono</code> to save space.
</p>

<p>
In the GUI you can find the video recorder under <span
class="menu-reference">Main menu bar &rarr; Tools &rarr; Capture &rarr;
Audio/Video</span>, which will open a the corresponding window, in which you
can specify all the above mentioned settings.
</p>

<p>
In the console, you can use the command <code><a class="external"
href="commands.html#record">record</a> start</code> to record to a default file
name, or you can use an additional parameter to specify a file. The command
<code><a class="external" href="commands.html#record">record</a> stop</code>
stops recording and <code><a class="external"
href="commands.html#record">record</a> toggle</code> toggles it. You can use
the <code>-audioonly</code> or <code>-videoonly</code> option to record only
sound or video.
</p>
<p>
If you want to put a recorded video on your web site, it is better to transcode
the audio to MP3 or Vorbis format, as this makes the file a lot smaller.
YouTube supports the ZMBV codec, so if you want to upload your recording you do
not need to transcode the video. If you want to share your video with people
who do not have (or want to install) the ZMBV codec, you should still transcode
it, of course. This can be done with programs such as <a class="external"
href="http://www.virtualdub.org/">Virtual Dub</a> (Windows) or <a
class="external" href="http://www.mplayerhq.hu/">MPlayer's MEncoder</a>
(Linux/UNIX). For YouTube you may want to use the command <code><a
class="external" href="commands.html#record">record_chunks</a></code> instead:
it will enable you to chop up your video in several parts and enables
<code>-doublesize</code> automatically.
</p>

<p>
Recording as explained above will happen in real-time. This can be annoying if
you want to make a demonstration video, because you all mistakes will be
recorded as well. To work around this, you can also use the <code><a
class="external" href="commands.html#reverse">reverse</a></code> feature during
the scene you want to record. After the scene, reverse to the beginning, start
the recording as explained above and let the scene replay relaxedly. You can
even speed it up using the <a class="external"
href="commands.html#throttle">throttle</a> setting. This method of recording is
also useful when real-time recording has a big impact on the performance of
openMSX on your hardware. See also <a class="internal" href="#reverse">the
chapter about this feature</a>.
</p>

<h2><a id="audio">8. Audio</a></h2>

<h3><a id="audiosettings">8.1 Audio Settings</a></h3>

<p>
Most audio related settings can be found under the <span
class="menu-reference">Main menu bar &rarr; Settings &rarr; Sound</span> menu.
</p>

<p>
There is a <code><a class="external"
href="commands.html#master_volume">master_volume</a></code> setting, which
controls the overall output volume of openMSX (it applies to all sound
devices). Volume 0 means no sound, volume 100 is maximum.
</p>

<p>
There is also a <code><a class="external"
href="commands.html#mute">mute</a></code> setting, to disable all sound from
openMSX at once. It can be on (muted) or off (sound is audible). By default,
mute is bound to the F12 key.
</p>

<p>
There are also settings for each emulated sound device. These can be found
under the <span class="menu-reference">Main menu bar &rarr; Settings &rarr;
Sound &rarr; Show sound chip settings</span> option in the menu.
</p>

<p>
For each sound device there is a volume setting.
Volume 0 means no sound, volume 100 is maximum. In the console you can do this, for example: <code>set <a
class="external" href="commands.html#soundchip_volume">"MSX Music_volume"</a>
50</code>.
</p>

<p>
For each sound device, you can control the distribution of the sound output of
this chip over the left and right channel, with the balance setting. This is
very similar to the balance knob on (older?) hifi equipment.
Example: <code>set <a class="external"
href="commands.html#soundchip_balance">PSG_balance</a> -100</code>, which sets
the PSG entirely to the left channel. Any sound device can also be individually
(un)muted using the <a class="external"
href="commands.html#mute_channels">mute_channels</a> command.
</p>

<p>
If you'd like to apply some special effects to the PSG sound, you should take a
look at the <a class="external"
href="commands.html#psg_vibrato_frequency">vibrato</a> and <a
class="external" href="commands.html#psg_detune_frequency">detune</a>
(both percent and frequency) settings.
</p>

<h3><a id="midi">8.2 MIDI</a></h3>

<p>
Currently, openMSX supports the following MSX MIDI interfaces:
</p>
<ul>
<li>MSX-MIDI of the MSX turboR GT and the μ・PACK,</li>
<li>the MIDI interface of the Philips Music Module (NMS 1205),</li>
<li>the MIDI interface of the Yamaha SFG-01 and SFG-05 module (also present in the Yamaha CX5M series of machines),</li>
<li>the FAC MIDI Interface, and</li>
<li>the JVC (UK) MSX MIDI interface.</li>
</ul>
<p>
To use MIDI, start openMSX with a machine that has a MIDI interface built in,
or add one of the mentioned MIDI interface extensions. Then plug a MIDI out
and/or MIDI in device into that MSX MIDI interface using the GUI
<span class="menu-reference">Main menu bar &rarr; Connector</span> menu or the
openMSX <a class="internal" href="#console">console</a>.
</p>

<h4>MIDI Out</h4>

<p>
You can connect the MIDI out of the MSX to a host MIDI device, such as a
physical MIDI out port, a soft synthesizer or a sequencer program. On Windows,
Linux and macOS, host MIDI devices are made available as pluggables in openMSX.
On macOS, you can opt to instead select <code>Virtual OUT</code> to create a
virtual MIDI port for Mac MIDI software to connect to.
</p>

<p>
For example, use the machine <code>Panasonic_FS-A1GT</code> and plug into the
<a class="external" href="https://sourceforge.net/projects/munt/">Munt</a> soft
synthesizer (MT-32 emulator) using <span class="menu-reference">Main menu bar
&rarr; Connectors</span> menu, or with the console command <code><a
class="external" href="commands.html#plugunplug">plug</a> msx-midi-out Munt\
MT-32</code>.
</p>
<p>
The exact naming of the host MIDI devices differs per platform. In the console
you can use tab completion to see the options: type <code>plug
msx-midi-out</code> and hit TAB twice.
</p>

<p>
The <code>midi-out-logger</code> MIDI device is available on all platforms and
logs MIDI events to a file.
</p>
<p>
You can specify the file to log to using <code>set
<a class="external"
href="commands.html#midi-out-logfilename">midi-out-logfilename</a></code>.
The log is a raw binary log of the bytes written by the MIDI interface, with no
timing information. Therefore its usefulness is mostly limited to debugging.
</p>
<p>
On UNIX-like systems, it is possible to log to a MIDI device node, for example
<code>/dev/midi</code> and configure the sound system to send those notes to a
soft synthesizer. This is harder to configure than using for example the ALSA
MIDI out device, so it's only recommended when no platform-specific MIDI
devices are available in openMSX. On MSX Resource Center there is <a
class="external"
href="http://www.msx.org/forum/semi-msx-talk/emulation/openmsx-timidity">a
forum thread</a> which describes how to connect openMSX to Timidity via
<code>/dev/midi</code>.
</p>

<h4>MIDI In</h4>

<p>
Vice versa, the MIDI in port can also receive data from the system by plugging
a device into <code>msx-midi-in</code> (for the Panasonic FS-A1GT; use the
appropriate connector name for other devices). Analogous to the above mentioned
outputs you can connect a <code>midi-in-reader</code> which reads from a file
or <code>/dev/midi</code> on Linux. On Windows and macOS available MIDI devices
show up as separate pluggables. On macOS a <code>Virtual IN</code> port is
available as well.
</p>

<h3><a id="soundlogger">8.3 Recording Audio to File</a></h3>

<p>
openMSX records the sound at the exact speed at which it should be produced, no
matter the speed at which the emulation was running while recording. Note that
recording sound to the uncompressed WAV format will take a lot of disk space:
at 44.1 kHz it will take about 176 kB per second.
</p>

<p>
In the GUI you can find the audio recorder under <span
class="menu-reference">Main menu bar &rarr; Tools &rarr; Capture &rarr;
Audio/Video</span>, which will open a the audio/video recording window. Just
select <span class="menu-reference">only Audio</span> to log to said WAV file.
<p>

<p>
The underlying console command to start the recording of sound is <code><a
class="external" href="commands.html#soundlog">soundlog</a> start</code>. It
will automatically choose a file name and save it in the <code>soundlogs</code>
directory in your personal openMSX folder. You can also add an extra parameter
to specify the filename for the new WAV file. To stop recording, use <code><a
class="external" href="commands.html#soundlog">soundlog</a> stop</code>. You
can toggle the recording status using <code><a class="external"
href="commands.html#soundlog">soundlog</a> toggle</code>, which is useful if
you <code><a class="external" href="commands.html#bind">bind</a></code> this
command to a hotkey.
</p>

<p>
There is also an advanced feature for recording audio to file: you can record
individual channels of sound chips to individual files on disk. The sound is in
the native frequency of the sound chip this time, which means that for chips
like PSG or SCC (which run at very high frequencies), the files will be huge.
(You have been warned!) This feature can be controlled in the GUI via <span
class="menu-reference">Main menu bar &rarr; Settings &rarr; Sound &rarr; Show
sound chip settings</span> and in that window click on the "channels" checkbox,
which opens a window where you can fill in a file name for each channel you
want to record with. Perhaps it is easiest to control from the console with the
<code><a class="external"
href="commands.html#record_channels">record_channels</a></code> command. Note
that in contrast to the <code><a class="external"
href="commands.html#soundlog">soundlog</a></code> command, the output file of
this command ends up in the current directory and not in a special directory.
We hope you can use this command to study the fantastic compositions of MSX
software and make great remakes of them.
</p>

<h2><a id="usefulextras">9. Useful Extras</a></h2>

<h3><a id="savestate">9.1 Saving/Loading the State of the Machine</a></h3>

<p>
A feature of emulators which is particularly useful is saving the state of the
emulated machine to a file, in order to load it again later and continue
exactly where you left off when saving. Not only useful for games, but also for
debugging or testing. For openMSX we designed this feature in such a way
that it is trying really hard to be future proof. So, you
don't have to be afraid to upgrade to a new version of openMSX: your save
states will remain usable!
</p>

<p>
In the GUI's <span class="menu-reference">Main menu bar &rarr; Save
state</span> menu you find all options to (quick) load and save states and even
more. </p>

<p>
The easiest way to use it is by using the keyboard shortcuts for quickly saving
and loading a state, see the shortcut hints in the aforementioned menu and also the <a class="internal" href="#keymapping">key mapping
section</a>. These shortcuts basically use the <a class="external"
href="commands.html#savestate">savestate</a> and loadstate commands, with the
parameter <code>quicksave</code>, i.e. they use a savestate file with the name
'quicksave'. You can also use the commands directly yourself, with the argument
as the name of the slot you save the state to (use TAB or the <code><a
class="external" href="commands.html#savestate">list_savestates</a></code>
command to see your previously saved states). Without having to browse the file
system of your computer, you can also conveniently delete existing save games
with the <code><a class="external"
href="commands.html#savestate">delete_savestate</a></code> command.
</p>

<p>
Note that when saving the state of the machine, a screenshot will also be saved
with it, so that those could be used for save state browsing.
</p>

<h3><a id="reverse">9.2 Reverse</a></h3>

<p>
Inspired by the meisei MSX emulator, openMSX also has a reverse feature.
This enables you to go back in MSX time, so you can correct mistakes in your
game play or you can watch what you did (and also record a video of it).
</p>

<p>
You can go back in time a second using the <a
class="internal" href="#keymapping">key binding</a> for this: PageUp. Once you
went back, openMSX will replay whatever you did when you were at this time for
the first time, until it got at the point where you went back. From then on,
everything will continue as normal. If you touched any control of your MSX
during replay, you have indicated to take over from the replay. If you do that,
the rest of the replay is erased (openMSX forgets that that future ever
happened). This is the typical way to correct mistakes using this feature.
</p>

<p>
While replaying, you can also jump forward in time ("Back to the Future") using
PageDown. Also, you can go back a specific amount of seconds or to an absolute
moment in (MSX) time, all using the <code><a class="external"
href="commands.html#reverse">reverse</a></code> command. (This can also be
useful when you're developing/debugging MSX software.)
</p>

<p>
If all of this sounds a bit confusing, you can use the reverse bar (by default,
it's placed in the bottom right corner, hover there in the main openMSX window
to make it appear), which will show you a visualisation of all of this on
screen. The bar represents the time while the feature was enabled and shows the
current moment in time (the red indicator). You can click on it to jump back
and forward in time. The vertical lines indicate times when snapshots were
made. The bar will fade out after a while, but hovering your cursor over it
makes it reappear. If you want to get rid of the bar, toggle this setting in
the GUI menu: <span class="menu-reference">Main menu bar &rarr; Save state
&rarr; Reverse/replay settings &rarr; Show reverse bar</span>. (This will not
turn off the reverse feature itself.)
</p>

<p>
If you want to disable the reverse feature, you can use <span
class="menu-reference">Main menu bar &rarr; Save state &rarr; Reverse/replay
settings &rarr; Enable reverse/replay</span> or the underlying <code><a
class="external" href="commands.html#reverse">reverse stop</a></code> console command.
And if you don't want it to restart again anymore, uncheck the <span
class="menu-reference">Main menu bar &rarr; Save state &rarr; Reverse/replay
settings &rarr; Auto enable reverse</span> <a class="external"
href="commands.html#auto_enable_reverse">setting</a>.
</p>

<p>
If you want to save a very compact recording of what you did, or want to have
the possibility to start off in the middle of a recording, you can save your
complete replay to a file with <span
class="menu-reference">Main menu bar &rarr; Save state &rarr; Save
replay</span> or the <code><a class="external"
href="commands.html#reverse">reverse savereplay</a></code> command. They can
also be loaded of course, with <span
class="menu-reference">Main menu bar &rarr; Save state &rarr; Load
replay</span> or <code><a class="external"
href="commands.html#reverse">reverse loadreplay</a></code>.
</p>

<h3><a id="trainer">9.3 Game Trainer</a></h3>

<p>
openMSX includes a game trainer system. You start with it by using the GUI
menu: <span class="menu-reference">Main menu bar &rarr; Tools &rarr; Trainer Selector</span> This will open a window in which you
must first select the game you want to use a trainer for from the list of
supported games. When a game is selected, you see the list of cheats displayed
for the game, where you can also toggle the different cheats you want to
activate.
</p>

<p>
As with most openMSX functionality, the trainers can also be used from the <a
class="internal" href="#console">console</a>, and even there it is very easy to
use. As always, you could type: <code>help <a class="external"
href="commands.html#trainer">trainer</a></code>, for some basic help.
</p>

<p>
Suppose you want to cheat on Metal Gear. Then it would be useful to type:
<code>trainer Metal[TAB]</code>, which will expand to: <code>trainer Metal\
Gear</code>. When you then press enter, you see which cheats are available in
the Metal Gear trainer. You can activate them by typing e.g.: <code>trainer
Metal\ Gear 1 2 3 4</code>. This will activate (toggle) the first 4 cheats (as
the list will tell you which is printed after the command: the crosses indicate an
active cheat). You can also use the descriptions instead of the numbers:
<code>trainer Metal\ Gear "enemy 1 gone" "enemy 2 gone"</code>. Or, if you want
to activate all cheats you can simply type: <code>trainer Metal\ Gear
all</code>.
</p>

<p>
If this sounds a bit difficult for you, just try it out. It's really much
easier when you actually work with it.
As always in the console, using TAB to complete your commands and their options
proves to be very useful!
</p>

<h3><a id="debugdevice">9.4 Debug Device</a></h3>

<p>
This chapter describes how an MSX programmer can use the openMSX built-in debug
device. This is an artificial MSX device that is connected to an MSX I/O port.
It can be used to send debug messages to the host operating system.
</p>

<p>
Note that openMSX also contains built-in debugging functions, which can be
accessed with the <code><a class="external"
href="commands.html#debug">debug</a></code> console command. With that debugger
you can read and write all registers and memory of almost all devices that are
supported in openMSX. It also supports break points, watch points and stepping.
See the <span class="menu-reference">Main menu
bar &rarr; Debugger</span> menu for the most common debugging options.
</p>

<h4><a id="debugdeviceenable">9.4.1 Enabling the Debug Device</a></h4>

<p>
To enable the debug device, insert the <code>debugdevice</code> extension. To
do this when starting openMSX, simply add <code>-ext debugdevice</code> to the
openMSX command line. If openMSX is already running, you can use the
<code><a class="external" href="commands.html#ext">ext</a></code>
console command.
</p>

<p>
You can use the <code><a class="external"
href="commands.html#debugoutput">Debug Device output</a></code> setting to specify the
file name to write the debug output to.
</p>

<h4><a id="debugdeviceports">9.4.2 Output Ports</a></h4>

<p>
Controlling the device is done from within an MSX program. For this purpose, the
output ports 0x2E and 0x2F are used. The first port is the Mode Set Register.
Bytes sent to this port have the following meaning.
</p>
<table>
  <tr> <th>bit(s)</th><th>meaning</th> </tr>
  <tr> <td>7  </td> <td>unused</td> </tr>
  <tr> <td>6  </td> <td>line feed mode (0 = line feed at mode change, 1 no line feed)</td> </tr>
  <tr> <td>5-4</td> <td>output mode (0 = OFF, 1 = single byte, 2 = multi byte)</td> </tr>
  <tr> <td>3-0</td> <td>mode-specific parameters (see below)</td> </tr>
</table>

<p>
When using mode 1, single byte mode, the lower 4 bits each enable a particular
output format:
</p>
<table>
  <tr> <th>bit(s)</th><th>meaning</th> </tr>
  <tr> <td>3</td> <td>ASCII mode on/off</td> </tr>
  <tr> <td>2</td> <td>decimal mode on/off</td> </tr>
  <tr> <td>1</td> <td>binary mode on/off</td> </tr>
  <tr> <td>0</td> <td>hexadecimal mode on/off</td> </tr>
</table>
<p>
So, every parameter bit turns an output format on or off and more than one
output format can be specified at the same time.
</p>

<p>
The parameters for mode 2 (multi byte mode) are as follows:
</p>
<table>
  <tr> <th>bit(s)</th><th>meaning</th> </tr>
  <tr> <td>3-2</td> <td>unused</td> </tr>
  <tr> <td>1-0</td> <td>mode (0 = hex, 1 = binary, 2 = decimal, 3 = ASCII mode)</td> </tr>
</table>

<h4><a id="debugdevicemode1">9.4.3 Single Byte Mode</a></h4>

<p>
In mode 1, any write to port 0x2F will result in output. This way, the
programmer can see if a specific address is reached by adding a single
<code>OUT</code> to the code. The output depends on the parameters set with the
mode register. Each bit represents a specific format, and by turning the bits
on and off, the programmer can decide which formats should be used.
</p>

<p>
Here is an example:
</p>
<pre>
LD  A,65
OUT ($2f),A
</pre>

<p>
This will give the following output:
</p>

<pre>41h 01000001b 065 'A' emutime: 36407199578
</pre>
<p>
(when all bits are on, mode register = 0x1F)<br/>
or
</p>
<pre>41h 065 'A' emutime: 36407199578
</pre>
<p>
(when the binary bit is off, mode register = 0x1D)<br/>
or
</p>
<pre>41h emutime: 36407199578
</pre>
<p>
(when only the hexbit is on, mode register = 0x11)<br/>
and so on.
</p>

<p>
The EmuTime part is a special number that keeps track of the openMSX emulation.
The larger this number is, the later the event took place. This is a great way
to get an idea of the timing of things.
</p>
<p>
If the character to print is a special character, like carriage return,
linefeed, beep or tab, the character between the ' ' will be a dot (.) and the
normal character is 'displayed' at the very end of the line, so it won't mess up
the layout of the whole line.
</p>


<h4><a id="debugdevicemode2">9.4.4 Multi Byte Mode</a></h4>

<p>
Unlike mode 1, the data in this mode is always shown in one mode only. It's
either in hex mode, binary mode, decimal mode or ASCII mode, but never a
combination. Also the EmuTime bit is left out.
</p>

<p>
Here is an example:
</p>
<pre>
LD  A,xx
OUT ($2e),A
LD  A,$41
OUT ($2f),A
OUT ($2f),A
OUT ($2f),A
</pre>

<p>
If we substitute <code>$20</code> for <code>xx</code>, we get:
</p>
<pre>41h 41h 41h</pre>
<p>
and if we substitute <code>$22</code> for <code>xx</code>, we get:
</p>
<pre>065 065 065</pre>
<p>
The extra zero is added to keep alignment.  Finally, if we want ASCII
output, all we need to do is change <code>xx</code> for <code>$23</code>:
</p>
<pre>AAA</pre>
<p>
In this special case, the space in between the data is left out. Any special
character like carriage return, linefeed, beep or tab will be printed as you
would expect.
</p>

<h3><a id="programmabledevice">9.5 Programmable Device</a></h3>

<p>
This chapter describes briefly the built-in programmable device, a resource that
could prove useful for driver or hardware developers writing and debugging
software on openMSX instead of a real MSX. The programmable device is a virtual
MSX device that can be connected on the fly to a user-defined list of I/O ports.
It can be used to create a two-way communication between the virtual computer
and the host operating system by using the high-level Tcl language that openMSX
provides. It goes without saying that you must know how to use the Tcl language
to use this feature.
</p>
<p>
Note that this is not intended to be used as a drop-in replacement for
resource-intensive hardware like VDPs. Tcl is overall a very slow language, but
a programmable device opens up possibilities for using openMSX as a development
tool that were not possible before.
</p>
<p>
Note there's some overlap between this device and the <code><a class="external"
href="commands.html#debug">debug watchpoint add read_io/write_io</a></code>
command. Both can be used to make Tcl react to I/O read/write operations. This
device is more suited for completely new functionality. The debug command is
more suited to intercept communication with existing MSX devices.
</p>

<h4><a id="programmabledeviceenable">9.5.1 Enabling the Programmable Device</a></h4>

<p>
To enable the programmable device, insert the <code>programmabledevice</code>
extension. To do this when starting openMSX, simply add
<code>-ext programmabledevice</code> to the openMSX command line. If openMSX is
already running, you can use the
<code><a class="external" href="commands.html#ext">ext</a></code> console command.
</p>

<h4><a id="programmabledeviceports">9.5.2 Device Ports and callbacks</a></h4>

<p>
Device ports are a list of I/O ports connected between the guest computer and
the Tcl environment. This means that anything a Z80 assembly program sends to
one of these I/O ports using an OUT instruction automatically calls an "output
callback" (a Tcl procedure) to receive the data on the Tcl side. You must
declare your own output callback, otherwise the programmable device will do
nothing when it receives a byte. Your callback must have two parameters: port
and value (2 8-bit values) the return value from this callback is ignored.
</p>
<p>
Alternatively, anything a Z80 assembly program reads from one of these I/O ports
using an IN instruction automatically calls an "input callback" on the Tcl side.
That callback produces the value that will be received by the Z80. You also must
declare your own input callback, otherwise the programmable device will return
0xFF. An input callback receives a (8-bit) port number as the only parameter,
and it must return an 8-bit value.
</p>
<p>
The third kind of callback you can create is the "reset callback". This one has
no parameters and the return value is ignored. It can be useful for setting back
an initial state when the MSX reboots.
</p>
<p>
You can check the 4 settings that Programmable Device uses with the <a
class="external" href="commands.html#help">help</a> command, but briefly:
</p>
<div class="commandline">
    <a class="external" href="commands.html#set">set</a> {Programmable Device
ports} {6 7}
</div>
<p>
tracks I/O ports 6 and 7.
</p>
<div class="commandline">
    <a class="external" href="commands.html#set">set</a> {Programmable Device
reset callback} "my_reset_proc"
</div>
<p>
connects the reset event with your previously declared "my_reset_proc" callback.
</p>
<div class="commandline">
    <a class="external" href="commands.html#set">set</a> {Programmable Device
output callback} "my_output_proc"
</div>
<p>
connects the "OUT instruction" event with your previously declared
"my_output_proc" callback.
</p>
<div class="commandline">
    <a class="external" href="commands.html#set">set</a> {Programmable Device
input callback} "my_input_proc"
</div>
<p>
connects the "IN instruction" event with your previously declared
"my_input_proc" callback.
</p>

<h3><a id="sdcdb">9.6 SDCC Debugger</a></h3>

<p>
openMSX includes the SDCC Debugger called sdcdb, a Tcl script that mimics GDB (GNU Debugger) and allows you to inspect programs compiled with the Small Device C Compiler (SDCC) from the console. You just need to compile your SDCC code with the <code>-debug</code> flag to create a CDB file with symbols and their respective addresses and then call <code>sdcdb open &lt;directory&gt;</code> where the CDB file and source code are. Now you can inspect the program while it executes. For instance, to create a breakpoint at file <code>main.c</code>, line 155 from your source code, you can type:
</p>

<div class="commandline">
    sdcdb break main.c:155
</div>

<p>A SDCDB breakpoint is a regular breakpoint and it can be listed with the <code>debug breakpoint list</code> command. When a breakpoint is triggered, you can inspect the source code around it with command <code>sdcdb info</code>. There are two commands that executes code step by step. The first is <code>sdcdb step</code>, which executes C code line by line and goes inside function calls. It is equivalent to the <code>step_in</code> command from the console. The second is <code>sdcdb next</code>, which executes C code line by line but doesn't go inside function calls. It is equivalent to the <code>step_over</code> command from the console. The useful <code>sdcdb laddress &lt;address&gt;</code> will display source code under the given memory address since sdcdb is aware of the program's source code, like GDB. You can type <code>help sdcdb</code> for more details or check out the comments in <code>sdcdb.tcl</code> script for more examples.</p>

<h2><a id="contact">10. Contact Info</a></h2>

<p>
Because openMSX is still in heavy development, feedback and bug reports are very
welcome!
</p>

<p>
If you encounter problems, you have several options:
</p>

<ol>
<li>
Go to our IRC channel: <a class="external"
href="ircs://irc.libera.chat:6697/#openMSX"><code>#openMSX</code> on
<code>libera.chat</code></a>
and ask your question there. Also reachable via <a class="external"
href="https://web.libera.chat/#openMSX">webchat</a>! If you don't get a reply
immediately, please stick around for a while, or use one of the other contact
options. The majority of the developers lives in time zone GMT+1. You may get
no response if you contact them in the middle of the night... </li>
<li>
Post a message on <a class="external"
href="http://www.msx.org/forum/semi-msx-talk/openmsx">the openMSX forum on
MRC</a>.
</li>
<li>
Create a new issue in the
<a class="external" href="https://github.com/openMSX/openMSX/issues">openMSX
issue tracker</a>
on GitHub.
You need a (free) log-in on GitHub to get access.
</li>
<li>
Contact us and other users via one of the mailing lists. If you're a regular
user and want to discuss openMSX and possible problems, join our
<code>openmsx-user</code> mailing list.
If you want to address the openMSX developers directly, post a message to the
<code>openmsx-devel</code> mailing list.
More info on the
<a class="external" href="https://sourceforge.net/p/openmsx/mailman">openMSX mailing lists</a>,
including an archive of old messages, can be found at SourceForge.
</li>
</ol>

<p>
In any case, try to give as much information as possible when you describe your
bug or request.
</p>

</body>
</html>

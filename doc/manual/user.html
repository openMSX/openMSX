<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.0//EN"
"http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<link title="Purple" rel="stylesheet" href="manual-purple.css" type="text/css" />
<link title="Minty" rel="alternate stylesheet" href="manual-minty.css" type="text/css" />
<link title="Plain" rel="alternate stylesheet" href="manual.css" type="text/css" />
<title>openMSX User's Manual</title>
</head>

<body>

<h1>openMSX User's Manual</h1>

<h2>Contents</h2>

<ol class="toc">
	<li><a class="internal" href="#intro">1. Introduction</a>
		<ol class="toc">
			<li><a class="internal" href="#newver">1.1 New Versions of this Document</a></li>
			<li><a class="internal" href="#purpose">1.2 Purpose</a></li>
			<li><a class="internal" href="#contrib">1.3 Contributors</a></li>
			<li><a class="internal" href="#history">1.4 Revision History</a></li>
		</ol>
	</li>
	<li><a class="internal" href="#starting">2. Starting the Emulator</a>
		<ol class="toc">
			<li><a class="internal" href="#machines">2.1 Machines</a></li>
			<li><a class="internal" href="#extensions">2.2 Extensions</a></li>
			<li><a class="internal" href="#otheroptions">2.3 Other Command Line Options</a></li>
		</ol>
	</li>
	<li><a class="internal" href="#controlling">3. The Console and Settings</a>
		<ol class="toc">
			<li><a class="internal" href="#console">3.1 Console Introduction</a></li>
			<li><a class="internal" href="#importantconsole">3.2 Some Simple Console Commands</a></li>
			<li><a class="internal" href="#settings">3.3 Settings</a></li>
			<li><a class="internal" href="#plug">3.4 Plug</a></li>
		</ol>
	</li>
	<li><a class="internal" href="#media">4. Running Media</a>
		<ol class="toc">
			<li><a class="internal" href="#roms">4.1 Running ROM Software</a></li>
			<li><a class="internal" href="#disks">4.2 Running Disk Software</a>
				<ol class="toc">
					<li><a class="internal" href="#diskimages">4.2.1 Using Disk Images</a></li>
					<li><a class="internal" href="#dirasdisk">4.2.2 Using Directories as Disks</a></li>
					<li><a class="internal" href="#realdisks">4.2.3 Using Real Disks</a></li>
					<li><a class="internal" href="#harddisks">4.2.4 Emulating MSX Harddisks</a></li>
				</ol>
			</li>
			<li><a class="internal" href="#tape">4.3 Running Tape Software</a></li>
		</ol>
	</li>

	<li><a class="internal" href="#input">5. Input Devices</a>
		<ol class="toc">
			<li><a class="internal" href="#keymapping">5.1 Key Mapping</a></li>
			<li><a class="internal" href="#joystick">5.2 Joystick</a></li>
			<li><a class="internal" href="#mouse">5.3 Mouse</a></li>
		</ol>
	</li>

	<li><a class="internal" href="#video">6. Video</a>
		<ol class="toc">
			<li><a class="internal" href="#renderers">6.1 Renderers</a></li>
			<li><a class="internal" href="#accuracy">6.2 Accuracy</a></li>
			<li><a class="internal" href="#scalers">6.3 Scalers</a></li>
			<li><a class="internal" href="#gamma">6.4 Gamma Correction</a></li>
			<li><a class="internal" href="#videoeffects">6.5 Special Effects</a></li>
			<li><a class="internal" href="#gfx9000">6.6 GFX9000/Video sources</a></li>
		</ol>
	</li>

	<li><a class="internal" href="#audio">7. Audio</a>
		<ol class="toc">
			<li><a class="internal" href="#audiosettings">7.1 Audio Settings</a></li>
			<li><a class="internal" href="#midi">7.2 MIDI</a></li>
		</ol>
	</li>

	<li><a class="internal" href="#debugdevice">8. Debug Device</a>
		<ol class="toc">
			<li><a class="internal" href="#debugdeviceenable">8.1 Enabling the Debug Device</a></li>
			<li><a class="internal" href="#debugdeviceports">8.2 The Output Ports</a></li>
			<li><a class="internal" href="#debugdevicemode1">8.3 Single Byte Mode</a></li>
			<li><a class="internal" href="#debugdevicemode2">8.4 Multi Byte Mode</a></li>
			<li><a class="internal" href="#debugdeviceoutput">8.5 Controlling the Output</a></li>
		</ol>
	</li>
	<li><a class="internal" href="#contact">9. Contact Info</a></li>
</ol>


<h2><a id="intro">1. Introduction</a></h2>

<h3><a id="newver">1.1 New Versions of this Document</a></h3>
<p>
The latest version of the openMSX manual can be found on the openMSX home page:
</p>
<p>
<a class="external" href="http://openmsx.sourceforge.net/manual/">http://openmsx.sourceforge.net/manual/</a>
</p>
<p>
You can also use this URL to get up-to-date versions of the hyper links
if you printed out this manual.
</p>

<h3><a id="purpose">1.2 Purpose</a></h3>
<p>
This manual is about openMSX, the open source MSX emulator that tries to achieve
near-perfect emulation by using a novel emulation model.
You can find more information about openMSX on the
<a class="external" href="http://openmsx.sourceforge.net/">openMSX home page</a>.
You can also download the emulator itself from there.
</p>

<p>
openMSX is in alpha state, which means that some things work but not all
features are implemented yet.
Many emulation features are implemented, but in terms of user interface
it is rather bare bones, unless you use the optional Graphical User Interface dubbed openMSX Catapult, which has separate <a class="external" href="http://openmsx.sourceforge.net/catapult-manual/">manuals</a> for now.
However, since the emulation is already pretty good,
it would be nice if non-insiders would be able to play with it, too.
For those people, we have written this guide.
It explains how you can make use of the features of the emulator, once you have got it running.
</p>

<p>
This manual tells you how you can use openMSX, once it has been installed and properly set up. You should be able to use most of the features of openMSX if you have read it.
If you are using using openMSX with Catapult, you don't have to pay attention to the exact command and setting names. However it is still useful to read this document to find out how openMSX works and learn its terminology.
</p>

<p>
<em>Disclaimer:</em>
We do not claim this guide is complete or even correct.
What you do with the information in it is entirely at your own risk.
We just hope it helps you enjoy openMSX more.
</p>

<h3><a id="contrib">1.3 Contributors</a></h3>

<p>
The following people contributed to this document in one way or another:
</p>
<ul>
<li>Jorrith Schaap</li>
<li>Manuel Bilderbeek</li>
<li>Maarten ter Huurne</li>
<li>other openMSX developers</li>
</ul>
<p>
Thanks to all of them!
</p>

<h3><a id="history">1.4 Revision History</a></h3>

<p>
This section gives an overview of the changes that were made to this document.
It doesn't contain every single modification (use the CVS log for that),
only the big picture.
</p>

<dl>

<dt>2005-01-26: Manuel Bilderbeek</dt>
<dd>
Updates for release 0.5.1.
</dd>

<dt>2004-09-28: Manuel Bilderbeek</dt>
<dd>
Updates for release 0.5.0, including some more elaborate explanations for several subjects.
</dd>

<dt>2004-05-20: Maarten ter Huurne</dt>
<dd>
Updates for release 0.4.0: restructured chapters and added more info about video settings.
</dd>

<dt>2004-01-16: Manuel Bilderbeek</dt>
<dd>
Updates for release 0.3.4: explanation of the scalers was added.
</dd>

<dt>2003-09-25: Maarten ter Huurne and Manuel Bilderbeek</dt>
<dd>
Split the User's Manual off from the openMSX HOWTO.
Converted to XHTML.
Restructured the document.
Rewrote some text to fit better in the new structure and format.
</dd>

<dt>2002, 2003: Manuel Bilderbeek &amp; others</dt>
<dd>
Various updates to the HOWTO.
</dd>

<dt>2002: Manuel Bilderbeek &amp; Jorrith Schaap</dt>
<dd>
Original text written as part of the openMSX HOWTO.
</dd>

</dl>

<h2><a id="starting">2. Starting the Emulator</a></h2>

<p>
In this chapter we will tell you how to select MSX machines and how to use extension cartridges.
</p>

<h3><a id="machines">2.1 Machines</a></h3>

<p>
If you start openMSX without any command line parameters, you will get the default machine, which is stored in the <code>machine</code> setting, see the <a class="external" href="setup.html#settings">Setup Guide</a>. If you did not change the default machine, you will get the C-BIOS MSX2+ machine.
</p>

<p>
To select a different MSX machine, use the <code>-machine</code> command line argument:
</p>
<div class="commandline">
    openmsx -machine Panasonic_FS-A1GT
</div>
<p>
The C-BIOS machines come with ROMs installed; for other machines you will have to install system ROMs yourself, see the <a class="external" href="setup.html#systemroms">Setup Guide</a> for details.
</p>

<h3><a id="extensions">2.2 Extensions</a></h3>

<p>
Extensions are simply MSX cartridges (extensions to the MSX system) that you can plug into the emulated MSX. openMSX ships with a lot of predefined extensions. Note that many of them require firmware ROMs to be installed in the <code>share/extensions/<em>name</em>/roms</code> directory or in <code>share/systemroms</code>.
</p>
<p>
We will use the FMPAC as an example. openMSX ships with a definition (XML file) for the FMPAC extension, but you will have to add the <code>fmpac.rom</code> firmware ROM yourself. When you have done so, you can insert an FMPAC into the emulated MSX machine with the following command line:
</p>
<div class="commandline">
    openmsx -ext fmpac
</div>
<p>
If you look in the <code>share/extensions</code> directory, you will see all the extensions known to openMSX. For example <code>-ext mbstereo</code> gives you the MoonBlaster stereo effect: FMPAC on the left speaker and MSX-AUDIO on the right speaker.
</p>

<h3><a id="otheroptions">2.3 Other Command Line Options</a></h3>

<p>
Often used other command line options will be discussed later in this manual. For a complete list of them, type the following command:
</p>
<div class="commandline">openmsx -h</div>


<h2><a id="controlling">3. The Console and Settings</a></h2>

<h3><a id="console">3.1 Console Introduction</a></h3>

<p>
openMSX has a built-in command interface called the <em>console</em>,
which allows you to control various aspects of openMSX while it is running.
You can access the console by pressing F10
(with default key mapping) when the focus is on the emulator window.
This will give you a command line in the openMSX window.
</p>

<p>
Typing <code>help</code> gives a list of commands.
If you type <code>help [command]</code> you will get help
for the specified command.
This manual describes a few important commands;
a full list can be found in the file <code>doc/commands.txt</code>.
The console can be used to change disk images, plug in joysticks or mice,
change settings at run time and to change key bindings, among others.
</p>

<p>
One very practical feature of the console command line is that you can use "completion" features. Just try typing half a command and then press the TAB key; openMSX will then try to finish the word you were typing or show the possibilities in case of ambiguities. You can use it also for file names, connectors, pluggables and settings.
</p>

<!--
<p class="todo">
Add the complete list of commands from commands.txt somewhere.
</p>
-->

<h3><a id="importantconsole">3.2 Some Simple Console Commands</a></h3>

<p>
You can reset your MSX with the Console command <code>reset</code> and quit openMSX with the command <code>quit</code>. Other commands will be discussed later on in this manual.
</p>

<h3><a id="settings">3.3 Settings</a></h3>

<p>
An interesting console command is <code>set</code>. You can use it to change the various
settings. E.g., you can use it to set the current renderer. <!-- If you use it without parameters, you will get a list of settings.--> If you issue set with only the setting (like <code>set renderer</code>), you will get the current value of that setting.
Settings that have only two possible values can also be toggled with the <code>toggle</code>
command (an example is the default key binding of F12 to <code>toggle
fullscreen</code>, see also below). A complete list of settings should also be in the file
<code>commands.txt</code> in the <code>doc</code> directory. Note that using the "tab completion" feature can help you a lot in getting an idea of what settings are possible, as it will only complete possible options. Just try that.
</p>
<!--
<p class="todo">
Add the complete list of settings in commands.txt somewhere.<br/>
</p>
-->

<p>
If the MSX goes too fast or too slow, adjust the emulation speed with the
<code>speed</code> setting, which has the speed percentage as parameter. So, typing <code>set
speed 120</code>, will let the emulated MSX run at 120% of normal MSX speed. This is useful for debugging purposes (slow down) or when you want to skip certain parts of a demo for example (speed up).
</p>

<p>
If you got the MSX sped up to maximum (<code>set throttle off</code>), but
openMSX is still not going fast enough for you, you can increase the
maxframeskip setting: <code>set maxframeskip 10</code> will mean that openMSX may
skip 10 screens to be displayed, just to get to the requested speed. Note that
you can also <em>force</em> openMSX to skip frames, with the minframeskip setting. This
sets the amount of frames that will be skipped always. Of course frame skipping
makes emulation a lot less accurate.
</p>

<p>
Some MSX machines like the Panasonic FS-A1GT have built in software (called firmware), that can be switched on and off via a switch on the machine itself. In openMSX the internal software is switched off by default, but you can switch it on with the following setting: <code>set firmwareswitch on</code>.
</p>

<p>
You can save all your current settings with the <code>save_settings</code> command. If you specify a file name after this command, the settings will not be saved to the default settings file (<code>share/settings.xml</code>), but to the specified file. At start up, alternative settings files can be loaded by using the <code>-setting</code> command line option. You can also use the <code>load_settings</code> command to load settings at run time. Settings that are not mentioned in the saved settings file that you are loading will be untouched. If you want openMSX to automatically save your settings when it exits, issue the following setting: <code>set save_settings_on_exit true</code>.
</p>

<h3><a id="plug">3.4 Plug</a></h3>

<p>
The console command <code>plug</code> can be used to plug the so called pluggables (devices) into connectors on the MSX. Examples of connectors are the joystick ports, the printer port, the MIDI in and out connector, the cassette port, etc. Examples of pluggables are joysticks and mice (see below), but also printer loggers and MIDI equipment. The command <code>plug</code> without any parameters will show a list of connectors and what pluggables are plugged into them. Using <code>plug [connector]</code> will only show what is plugged into [connector]. You will not be surprised that the command <code>plug [connector] [pluggable]</code> will plug the [pluggable] into the [connector].
</p>

<p>
Note that using the "tab completion" feature can help you a lot in getting an idea of what plug commands are possible, as it will only complete possible connectors and their possible pluggables. Also just try this.
</p>

<!--
<p class="todo">
Add the complete list of pluggables here.
</p>
-->

<h2><a id="media">4. Running Media</a></h2>

<p>
With this information, you can run most of the existing MSX software.
</p>

<h3><a id="roms">4.1 Running ROM software</a></h3>

<p>
Suppose you want to run the ROM file <code>galious.rom</code>. Then you simply type:
</p>
<div class="commandline">openmsx galious.rom</div>
<p>
and the emulated MSX will run the game. (Of course,
in this case, the file <code>galious.rom</code> should be in the current directory or in one
of the user directories you specified with the <code>user_directories</code> setting, see the <a class="external" href="setup.html">Setup Guide</a>.)
</p>

<p>
You can also explicitly indicate that the thing is a ROM image like this:
</p>
<div class="commandline">openmsx -cart galious.gam</div>
<p>
This lets openMSX know that the file <code>galious.gam</code> is a ROM cartridge and that openMSX should insert it in the first available free cartridge slot. You can also use <code>-carta</code> to explicitly specify cartridge slot A.
</p>
<p>
Or, maybe openMSX didn't have the ROM in the ROM database and failed auto detection of the mapper type. You can specify the mapper to <code>Konami</code> (formerly known as <code>KONAMI4</code>) like this:
</p>
<div class="commandline">openmsx galious.rom -romtype Konami</div>
<p>
Note that in practice you won't need this, since most ROM images are in the database or auto detected if they are not. The <code>-romtype</code> option should follow the ROM it applies to immediately on the command line.
</p>

<p>
If wanted, openMSX can apply IPS patches to ROM software before running it. IPS patches are files that describe a modification of the ROM you are applying it to, e.g. a translation or a cheat. This way you do not need to alter any files. To apply an IPS patch you have to provide the IPS filename like this:
</p>
<div class="commandline">openmsx -cart galious.rom -ips galiouspatch.ips</div>
<p>
As with the <code>-romtype</code> option, the <code>-ips</code> option on the command line must follow the ROM file it applies to directly. You can also use multiple <code>-ips</code> options if you want to apply multiple patches.
</p>

<h3><a id="disks">4.2 Running Disk Software</a></h3>

<h4><a id="diskimages">4.2.1 Using Disk Images</a></h4>

<p>
To run a disk image, you can type:
</p>
<div class="commandline">openmsx relax.dsk</div>
<p>
for example. Or, if you use a disk image with an extension that is not registered as such:
</p>
<div class="commandline">openmsx -diska relax.di</div>

<p>
You can also change disks at run time of course. Just type
</p>
<div class="commandline">
    diska &lt;diskimage&gt;
</div>
<p>
in the console to put the specified disk image in drive A. To eject the disk from drive A, use:
</p>
<div class="commandline">
    diska eject
</div>

<p>
Disk images in XSA format are also supported, use them as regular disk images, but do note that they are read only. The same counts for (g)zipped disk images. Note that in zipped disk images the first file that is packed into the zip file will be used as disk image.
</p>

<p>
If wanted, openMSX can also apply IPS patches to disk software before running it. This way you do not need to alter any files. To apply an IPS patch you have to provide the IPS filename like this:
</p>
<div class="commandline">openmsx SDSNAT1C.DSK -ips sdsnat1-eng.ips</div>
<p>
The <code>-ips</code> option must follow directly the disk image on the command line it applies to. You can also use multiple <code>-ips</code> options if you want to apply multiple patches.
</p>

<p>
You can also apply the patches when changing disks at run time. Just type something like
</p>
<div class="commandline">
    diska SDSNAT1C.DSK sdsnat1-eng.ips sd-cheat.ips
</div>
<p>
in the console to put the specified disk image SDSNAT1C.DSK in drive A, with both IPS patches applied.
</p>

<h4><a id="dirasdisk">4.2.2 Using Directories as Disks</a></h4>

<p>
The DirAsDsk feature permits you to use a directory on your host computer's
file system as a disk image for your emulated MSX.  Note that this has nothing
to do with harddisk emulation. It simply creates a
virtual disk structure in memory from the files that are in the directory
that you specified as if it were a disk image. So: </p>
<div class="commandline">
    openmsx -diska .
</div>
<p>
will try to put all files of the current directory on a disk image in memory and
start openMSX with it. The actual data is still read from/written to the files
in your directory so that if you change the content of the files, these changes
are immediately visible to the emulated MSX.  This way you can for instance
edit source files with your favourite text editor but compile them immediately in
the emulated MSX.
</p>
<p>
Adding files on the host OS doesn't have any effect on the disk in openMSX and
vice versa.
</p>
<p>
<em>Be careful when writing to files from your emulated MSX.</em><br/>
If you save an existing file on that disk in the emulated MSX (without
increasing the file size), the change is also reflected on the directory on the
host OS! If the files are bigger than the original size then the extra data
sectors needed will be stored in a hidden sector cache and the extra data will
not be reflected in the host OS files! When stopping the emulator, or
ejecting the fake disk, this sector cache is written in the same directory as
the original files, so that it can be loaded again when restarting the emulator.
So if you use the DirAsDsk feature on a real floppy disk, chances are that
you'll end up with a full disk when this cache is written!
</p>
<p>
Note that this feature is willfully kept very bare bones: it
doesn't support sub directories and it skips all remaining files if the virtual
disk is full. Its main purpose is to facilitate cross platform development.
</p>

<h4><a id="realdisks">4.2.3 Using Real Disks</a></h4>

<p>
To use a real disk, just specify <code>/dev/fd0</code> as a disk image. This is of
course a Linux (Unix, actually) specific feature, but for now it is usable. It
may be a bit slow though, with the FDC emulation enabled. It should be just as
slow as a real disk drive, however! Don't forget that you shouldn't have it
mounted to be able to use it this way. We recommend to use only write-protected
disks! It is possible that you damage the contents of your disk if you don't.
Windows users can try real disks by using the DirAsDsk feature. Because his
feature is still experimental, one should always use it with write protected
disks. Only regular disks with normal files will work with it; specify A: as
disk image to use it.
</p>


<h4><a id="harddisks">4.2.4 Emulating MSX Harddisks</a></h4>

<p>
openMSX only supports the emulation of the Sunrise IDE interface at the moment.
The extension for this is called 'ide'. The extension has a built in harddisk
configuration, in the form of a 100MB sized disk image. If you want to change
this, you'll have to edit the file in
<code>share/extensions/ide/hardwareconfig.xml</code>. If the harddisk image is
not present, or too small, the file is created or extended to the proper size. The image will end up in your openMSX user directory<code>/persistent/ide/untitled1/hd.dsk</code>.
</p>

<p>
The 'ide' extension needs the BIOS that can be flashed into the Sunrise IDE
interface. It can be downloaded from the <a class="external"
href="http://www.msx.ch/sunformsx/download/dl-ide.html">Sunrise for MSX web
site</a>.
</p>

<p>
When using this extension for the first time, one has to consider it as using a
real Sunrise IDE interface with a 100MB empty harddisk connected to the master
slot. How to proceed is written in the text files that come with the FDISK
program for IDE, downloadable from the <a class="external"
href="http://www.msx.ch/sunformsx/download/dl-ide.html">Sunrise for MSX web
site</a>. There is also a  <a class="external"
href="http://www.msx.org/forumtopic3015p15.html">thread</a> on the MSX Resource
Center forum that may give you valuable hints.
</p>

<p>
For clarity: because the emulation is done on a big disk image, you need free
disk space for this image, which can be quite big (default 100MB). Also, you
can't really use your normal PC harddisk as an MSX harddisk for this extension.
(Maybe on UNIX systems it works if you choose a device like
<code>/dev/hdb</code> as harddisk image file, but we have not tested it and do
note that it can cause loss of data of that partition or disk!!) This means
that there can be no data corruption of your PC's harddisk.
</p>

<p>
If you still want to use files from your real PC harddisk on the emulated MSX,
you have to use the DirAsDsk feature. See the <a class="internal"
href="#dirasdsk">DirAsDsk section</a> for more details.
</p>

<h3><a id="tape">4.3 Running Tape Software</a></h3>

<p>
openMSX supports WAV files for tape emulation! Just configure your MSX with a
cassette port (or use a premade MSX that already has it):
</p>
<div class="commandline">
     &lt;CassettePort/&gt;
</div>
<p>
Then type in the console:
</p>
<div class="commandline">
     plug cassetteport cassetteplayer
</div>
<div class="commandline">
     cassetteplayer &lt;file&gt;.wav
</div>
<p>
And then in MSX Basic, type:
</p>
<div class="commandline">
     run"cas:"
</div>
<p>
(or another command to load the program on 'tape'.)
</p>

<p>
Note that in Linux, one should not use the special file <code>/dev/pcm</code> for tape input. openMSX will try to read the file until the end, which doesn't exist.
</p>

<p>
You can also use the so-called CAS files. In the console, type:
</p>
<div class="commandline">
     cas &lt;tapeimage&gt;.cas
</div>
<p>
and
</p>
<div class="commandline">
     cas eject
</div>
<p>
to remove the tape from the virtual cassette player. This only works with a
patched BIOS ROM, though. You can find an example of the patch in
<code>exampleconfigs.xml</code>. This means you will have to modify the hardware configuration file of the MSX you are using. See the <a class="external" href="setup.html">Setup Guide</a>.
</p>

<p>
Because patching a BIOS is not really something you want, you can also use CAS
files with cassetteplayer as if they were WAV files. They are automatically
converted to WAV files, internally. Note that the loading time is drastically
longer this way. On the other hand, you will be able to hear the cassette
sounds now also with the CAS files... What is using cassettes with an MSX
without those characteristic sounds?
</p>

<p>
Other cassetteplayer related commands/settings you need to know of are:
</p>
<ul>
	<li><code>cassetteplayer rewind</code>, to rewind the tape</li>
	<li><code>cassetteplayer eject</code>, to eject the tape</li>
	<li><code>set cassetteplayer_volume</code>, to set the volume of the cassette player sound (yeah, the screeching tape sounds!)</li>
</ul>

<p>
A final note: saving to cassette is not supported in openMSX yet.
</p>

<h2><a id="input">5. Input Devices</a></h2>

<h3><a id="keymapping">5.1 Key Mapping</a></h3>

<p>
The special MSX keys are mapped as follows:
</p>

<table>
  <tr> <td>L-CTRL</td> <td>MSX CTRL key</td> </tr>
  <tr> <td>R-CTRL</td> <td>MSX dead (accents) key</td> </tr>
  <tr> <td>L-ALT</td> <td>MSX GRAPH key</td> </tr>
  <tr> <td>R-ALT</td> <td>MSX CODE key</td> </tr>
  <tr> <td>L-Windows</td> <td>MSX iee ('no') key</td> </tr>
  <tr> <td>R-Windows</td> <td>MSX hai ('yes') key</td> </tr>
  <tr> <td>F7</td> <td>MSX SELECT key</td> </tr>
  <tr> <td>F8</td> <td>MSX STOP key</td> </tr>
</table>

<p>
Several emulator functions are available under keys as well:
</p>

<table>
  <tr> <td>Pause</td> <td>Pause emulation</td> </tr>
  <tr> <td>ALT+F4</td> <td>Quit openMSX</td> </tr>
  <tr> <td>CTRL+Pause (Break)</td> <td>Quit openMSX (not in Windows)</td> </tr>
  <tr> <td>PrtScr</td> <td>Save current screen to a file (screen shot)</td> </tr>
  <tr> <td>F9</td> <td>Toggle full throttle (maximum speed)</td> </tr>
  <tr> <td>F10</td> <td>Toggle console display</td> </tr>
  <tr> <td>F11</td> <td>Toggle audio mute</td> </tr>
  <tr> <td>F12 or ALT+Enter</td> <td>Toggle full screen mode</td> </tr>
</table>
<!--
<p class="todo">
Make the table look better by using cellpadding stuff in the css.
</p>-->
<p>
The table above lists the default key mapping.
It can be changed using the <code>bind</code> command in the console. This setting can be saved along with the other settings, using the <code>save_settings</code> command.
</p>

<h3><a id="joystick">5.2 Joystick</a></h3>

<p>If you have a joystick connected to your PC, use the following command to connect it to the emulated MSX:
</p>
<div class="commandline">
    plug joyporta joystick1
</div>

<p>
To connect a fake joystick (emulated with the arrow keys), you can use this <code>plug</code> command:
</p>
<div class="commandline">
    plug joyporta keyjoystick
</div>
<p>
will connect a fake joystick to joystick port A. Button A of the joystick is mapped to the space bar and Button B to M, when using the default configuration. For now there can be only one keyjoystick. If you insist, you can manually change these bindings in the in the <code>settings.xml</code> file that you get if you save your settings. There is no way yet to set it with the console.
</p>

<h3><a id="mouse">5.3 Mouse</a></h3>

<p>
To connect a mouse, you can also use the <code>plug</code> command:
</p>
<div class="commandline">
    plug joyporta mouse
</div>
<p>
will connect a mouse to joystick port A. If you want the joystick emulation feature that some mice (like the Philips SBC-3810 and the Sony MOS-1) have, keep the left mouse key pressed when plugging it in, just as on a real MSX.
</p>

<p>
If you are using openMSX in windowed mode, it might be tricky to use the mouse. For that you may want to use the following setting: <code>set grabinput on</code>. This makes sure all input goes to openMSX. Your cursor cannot leave the openMSX window with this setting. Just turn it back to off, if you want to disable this again. If you only want to escape the window briefly, use this command: <code>escape_grab</code>. It permits you to leave the window, but the next time you enter it, the cursor is grabbed again.
</p>

<h2><a id="video">6. Video</a></h2>

<h3><a id="renderers">6.1 Renderers</a></h3>

<p>
A renderer is a part of the emulator that generates the graphical part of the emulation: the MSX 'screen'. At the moment, there are three working renderers:
</p>

<dl>

<dt>SDLHi</dt>
<dd>
This is the default renderer. It uses a window of 640&times;480 pixels. This renderer is not using any hardware acceleration and has a steady CPU time consumption. The CPU load can be quite high though. It is about 50% on Manuel's Athlon XP 1600+, when emulating a 3.5MHz MSX. The CPU load is smaller if you use a 16 bit per pixel video mode or when you have a CPU with MMX and/or MMXext extensions.
</dd>

<dt>SDLGL</dt>
<dd>
This renderer uses the OpenGL graphics library to optimise the rendering.
Because part of the rendering is done by the graphics hardware,
the CPU load can vary a lot.
The SDLGL renderer is only useful if you have a hardware accelerated
OpenGL library; a software GL implementation will be very slow.
See the Setup Guide for
<a class="external" href="setup.html#opengl">OpenGL performance tips</a>.
</dd>

<dt>SDLLo</dt>
<dd>
This renderer uses a window of only 320&times;240 pixels.
For 256&times;212 MSX modes, this is a good fit.
For 512&times;212 MSX modes, two pixels will be interpolated to produce
a single output pixel.
This renderer is mainly useful if you have a slow computer;
when using it full screen the low resolution is not a problem, especially because most MSX software uses a 256&times;212 mode.
</dd>

</dl>

<p>
You can set the renderer with the <code>renderer</code> setting. You can set full screen mode with the <code>fullscreen</code> setting. Again, to make these settings permanent, use the <code>save_settings</code> command to save them.
</p>

<p>
Note that openMSX can be compiled without the SDLGL renderer; if that is true for the build you're using, you will not be able to switch to the SDLGL renderer.
</p>

<h3><a id="accuracy">6.2 Accuracy</a></h3>

<p>
The <code>accuracy</code> setting controls how often the renderer is synchronised with the MSX video processor (VDP).
There are three options:
</p>

<dl>
<dt>screen</dt>
<dd>
Synchronise once per screen (frame).
Good enough for most MSX1 software, but will break most raster effects.
</dd>

<dt>line</dt>
<dd>
Synchronise at the start of a line.
This is good enough for most software.
This setting hides imperfections in raster effects,
which could be considered a useful feature.
</dd>

<dt>pixel</dt>
<dd>
Synchronise at the exact pixel where a change occurs.
This is the most realistic setting and therefore set as the default.
To see demos like Unknown Reality (scope part) and Verti correctly,
you should use this setting.
Also, you will see any imperfections in raster effects
just like they occur on a real MSX.
</dd>

</dl>

<p>
Higher accuracy creates a higher CPU load.
However, it is not as bad as it may seem at first:
openMSX synchronises only when it is actually needed,
so the amount of synchronisation points depends more on the program
you're running than on the accuracy setting.
</p>

<h3><a id="scalers">6.3 Scalers</a></h3>

<p>
Most MSX screen modes are only 256&times;212 pixels big. However, the SDLHi renderer uses a 640&times;480 screen mode to display the MSX screen. The conversion from the low resolution MSX image to the high resolution PC image is done by a <em>scaler</em>. openMSX contains several scalers:
</p>

<dl>

<dt>simple</dt>
<dd>
This scaler simply expands each MSX pixels to a square of 2&times;2 PC pixels.
This is the default scaler and it is fast.
The image looks blocky, especially diagonal edges.
</dd>

<dt><a class="external" href="http://scale2x.sourceforge.net/">Scale2x</a></dt>
<dd>
This scaler smoothes edges by using only original colours, so it will not give any blur. It is fast and its image is less blocky than that of the simple scaler. However, all corners are rounded, which does not look good on all graphics.
</dd>


<dt><a class="external" href="http://elektron.its.tudelft.nl/~dalikifa/">2xSaI</a></dt>
<dd>
This scaler smoothes edges by interpolating neighbouring pixels.
It is heaver on the CPU than the simple and Scale2x scalers.
It does a good job on most graphics, except for high-contrast edges;
for example white fonts on a black background get some nasty gray lines around them.
Also corners are rounded, similar to Scale2x.
</dd>

<dt><a class="external" href="http://www.hiend3d.com/hq2x.html">hq2x</a></dt>
<dd>
This scaler looks somewhat similar to 2xSaI, but its output is sharper.
Its complex algorithm is very heavy on the CPU; use this scaler only on fast PCs.
It does a good job on most graphics; it avoids excessive blurring and it keeps corners sharp.
On some graphics, it does not identify edges correctly, making those edges blocky instead of smooth.
</dd>

</dl>

<p>
A small demonstration of the algorithms can be found on <a class="external" href="http://openmsx.sourceforge.net">the openMSX web site</a>.
</p>

<h3><a id="gamma">6.4 Gamma Correction</a></h3>

<p>
PC monitors can have different gamma values than MSX monitors.
To compensate for this, openMSX has a gamma correction feature.
It is controlled by the <code>gamma</code> setting.
A value of 1.0 disables gamma correction; a lower value makes the image darker; a higher value makes it brighter.
</p>

<p>
If you want to know what gamma correction really means, read <a class="external" href="http://www.bberger.net/rwb/gamma.html">this page about monitor gamma</a>.
The gamma correction value you can set in openMSX should be the gamma of your PC screen divided by the gamma of the MSX screen.
I measured the gamma of my PC screen (TFT) at 2.0 and the gamma of my MSX monitor at 2.5. That puts the gamma correction at 2.0 / 2.5 = 0.8.
So if I enter that value, the openMSX image will have comparable brightness to the MSX image.
However, 0.8 is not the value I'm actually using: I prefer a brighter image than my MSX monitor, so I chose to use a gamma correction of 1.1.
</p>

<h3><a id="videoeffects">6.5 Special Effects</a></h3>

<p>
openMSX contains a couple of special effects that can be applied to the video output:
</p>

<dl>

<dt>deinterlace</dt>
<dd>
Interlacing is a technique to double the vertical resolution by splitting the image into two frames: the first frame the even lines are displayed, the second frame the odd lines are displayed.
The after glow on a TV and some processes in the human brain combine both frames into a single image. However, this process is not perfect and you can notice flickering, especially on horizontal lines.
The deinterlace feature combines the even and the odd frames into a single output frame, thus eliminating the flicker.
The <code>deinterlace</code> setting controls this feature:
it can be on (enabled) or off (disabled); it is enabled by default.
This feature works in the <code>SDLHi</code> and <code>SDLGL</code> renderers.
</dd>

<dt>scanlines</dt>
<dd>
On TVs and MSX monitors, you can see a small black space in between the display lines, especially when using NTSC.
The scanlines feature simulates this by drawing every other line a bit darker.
This feature works in the <code>SDLHi</code> and <code>SDLGL</code> renderers,
but is disabled when a scaler other than <code>simple</code> is used.
</dd>

<dt>blur</dt>
<dd>
TVs and MSX monitors are less sharp than PC monitors:
neighbouring pixels tend to blur into each other.
The blur feature simulates this by interpolating neighbouring pixels.
The <code>blur</code> settings control this:
0 means no blur (completely sharp), 50 means some blur (like a monitor),
100 means maximum blur (like a TV).
All other values between 0 and 100 are also possible of course.
This feature works in the <code>SDLHi</code> and <code>SDLGL</code> renderers,
but is disabled when a scaler other than <code>simple</code> is used.
</dd>

<dt>after glow</dt>
<dd>
The after glow feature blends each frame with the frame before it.
This results in moving objects leaving a trail (motion blur).
The <code>glow</code> setting controls the amount of after glow:
0 means no after glow, 100 means maximum after glow.
This feature works only in the <code>SDLGL</code> renderer.
</dd>

</dl>

<h3><a id="gfx9000">6.6 GFX9000/Video source</a></h3>

<p>
Since openMSX 0.5.1, experimental GFX9000 emulation is available. Note that it is indeed experimental; it is also incomplete, unoptimised and contains loads of bugs. One of these things is the fact that it does not work with the SDLGL renderer yet. Despite of all this, we thought you might wanted to play around with it anyway...
</p>

<p>
The real GFX9000 has an external video connector to which you can connect a
second monitor. Because of limits of the SDL library we used to create openMSX,
we cannot have more than one window for openMSX, so we cannot emulate a second
monitor. To see the GFX9000 in action, you need to switch the videosource
setting, which equals to a so-called SCART-switch in the real world: <code>set
videosource GFX9000</code>. If you started openMSX without GFX9000 extension,
this option is not available.
</p>

<p>
To get your normal MSX screen back, you should
type <code>set videosource MSX</code>. If you want to toggle with a hot key
between them, it might be useful to bind a key for it. E.g.: <code>bind F6
cycle videosource</code>.<br/>
<code>cycle</code> is a TCL command that cycles through the options of the setting in the parameter.
</p>

<h2><a id="audio">7. Audio</a></h2>

<h3><a id="audiosettings">7.1 Audio Settings</a></h3>

<p>
There is a <code>master_volume</code> setting, which controls the overall output volume of openMSX (it applies to all sound devices). Volume 0 means no sound, volume 100 is maximum.
</p>

<p>
There is also a <code>mute</code> setting, to disable all sound from openMSX at once. It can be on (muted) or off (sound is audible). By default, mute is bound to the F11 key.
</p>

<p>
Each sound device in the MSX you are emulating also has its own volume setting. Volume 0 means no sound, volume 100 is maximum. For example: <code>set "MSX Music_volume" 50</code>.
</p>

<p>
All mono sound devices have an additional mode setting. You can use it to select whether this device should be audible on the left channel ("left"), the right channel ("right") or both channels ("mono"). Example: <code>set PSG_mode left</code>. Any sound device can also be individually muted by setting the channel mode to "off".
</p>

<h3><a id="midi">7.2 MIDI</a></h3>

<p>
openMSX supports the MSX-MIDI interface of the MSXturboR GT.
To use this feature, start openMSX with the machine
<code>Panasonic_FS-A1GT</code> and plug in a MIDI device on the console.
For example:
</p>
<div class="commandline">
    plug msx-midi-out midi-out-logger
</div>
<p>
This logs all MIDI commands to a file.
Because there is no timing information logged, this is not very useful yet.
</p>

<p>
It's more interesting to connect MSX-MIDI to an actual PC MIDI device,
such as a MIDI out port or the internal synthesizer of your sound card.
On Linux, you can use the <code>midi-out-logger</code> and set a MIDI
device node, for example <code>/dev/midi</code>, as its output file. This is
done by default. To play with this setting, use <code>set
midi-out-logfilename</code>.  On Windows, real MIDI devices are separate
pluggables.
</p>

<h2><a id="debugdevice">8. Debug Device</a></h2>

<p>
This chapter describes how the debug device, built in openMSX, can be used to
the advantage of an MSX programmer. This device is an artificial MSX device
that is connected to an MSX I/O port. It can be used to send debug messages to
the host operating system.
</p>

<p>
Note that openMSX also contains real built in debugging functions, which can be
accessed with the <code>debug</code> command. More information about it is in
the aforementioned <code>commands.txt</code> file. With that debugger you can
read and write all registers and memory of almost all devices that are
supported in openMSX. It also supports break points and stepping.
</p>


<h3><a id="debugdeviceenable">8.1 Enabling the Debug Device</a></h3>

<p>
The easiest way to enable the debugdevice is to start openMSX with the
debugdevice extension. To do this, simply add <code>-ext debugdevice</code> to the
openMSX command line.
</p>

<p>
Another way to make the device work is to add it to the <code>hardwareconfig.xml</code> from
the machine that is used. If, for example, the device has to be used on the
Philips NMS 8250, the following lines can be added to the <code>hardwareconfig.xml</code>
file in the <code>share/machines/Philips_NMS_8250</code> directory.
</p>
<pre>
  &lt;DebugDevice id="Debug Device"&gt;
    &lt;io base="0x2E" num="2" type="O"/&gt;
    &lt;filename&gt;stdout&lt;/filename&gt;
  &lt;/DebugDevice&gt;
</pre>

<p>
The third line is optional and can specify any filename you
like, including <code>stdout</code>.
</p>


<h3><a id="debugdeviceports">8.2 The Output Ports</a></h3>

<p>
Controlling the device is done from within an MSX program. For this purpose, the
output ports 0x2E and 0x2F are used. The first port is the Mode Set Register. Bytes sent to this port have the following meaning.
</p>
<table>
  <tr> <th>bit(s)</th><th>meaning</th> </tr>
  <tr> <td>7  </td> <td> unused </td> </tr>
  <tr> <td>6  </td> <td> line feed mode (0 = line feed at mode change, 1 no line feed)</td> </tr>
  <tr> <td>4-5</td> <td> output mode (0 = OFF, 1 = single byte, 2 = multi byte)</td> </tr>
  <tr> <td>0-3</td> <td> parameters for mode 1 (see below)</td> </tr>
  <tr> <td>0-1</td> <td> parameters for mode 2 (see below)</td> </tr>
</table>

<p>
When using mode 1, single byte mode, these are the parameters:
</p>
<table>
  <tr> <th>bit(s)</th><th>meaning</th> </tr>
  <tr> <td>0</td> <td>  hexadecimal mode on/off </td> </tr>
  <tr> <td>1</td> <td>  binary mode on/off</td> </tr>
  <tr> <td>2</td> <td>  decimal mode on/off</td> </tr>
  <tr> <td>3</td> <td>  ASCII mode on/off</td> </tr>
</table>

<p>
So, every parameter bit turns an output format on or off and more than one output format can be specified at the same time.
</p>

<p>
The parameters for mode 2 (multi byte mode) are as follows:
</p>
<table>
  <tr> <th>bit(s)</th><th>meaning</th> </tr>
  <tr> <td>0-1</td> <td> mode (0 = hex, 1 = binary, 2 = decimal, 3 = ASCII mode)</td> </tr>
</table>

<h3><a id="debugdevicemode1">8.3 Single Byte Mode</a></h3>

<p>
In mode 1, any write to port 0x2F will result in output. This way, the
programmer can see if a specific address is reached by adding a single <code>OUT</code> to
the code. The output depends on the parameters set with the mode register. Each
bit represents a specific format, and by turning the bits on and off, the
programmer can decide which formats should be used.
</p>

<p>
Here is an example:
</p>
<pre>
LD  A,65
OUT ($2f),A
</pre>

<p>
This will give the following output:
</p>

<pre>41h 01000001b 065 'A' EmuTime:087a09c75a
(when all bits are on, mode register = 0x1F)
</pre>
<p>
or
</p>
<pre>41h 065 'A' EmuTime: 087a09c75a
(when the binary bit is off, mode register = 0x1D)
</pre>
<p>
or
</p>
<pre>41h EmuTime: 087a09c75a
(when only the hexbit is on, mode register = 0x11)
</pre>
<p>
and so on.
</p>

<p>
The EmuTime part is a special number that keeps track of the openMSX emulation.
The larger this number is, the later the event took place. This is a great way
to find out in what order things are called.
</p>
<p>
If the character to print is a special character, like carriage return,
linefeed, beep or tab, the character between the ' ' will be a dot (.) and the
normal character is 'displayed' at the very and of the line, so it won't mess up
the layout of the whole line.
</p>


<h3><a id="debugdevicemode2">8.4 Multi Byte Mode</a></h3>

<p>
In mode 2, writing to 0x2F does not output any text. All bytes written to this
register are stored in a buffer and only when the mode register is set again the
output is shown. Unlike mode 1, the data in this mode is always shown in one
mode only. It's either in hex mode, binary mode, decimal mode or ASCII mode, but
never a combination. Also the EmuTime bit is left out.
</p>

<p>
Here is an example:
</p>
<pre>
LD  A,xx
OUT ($2e),A
LD  A,$41
OUT ($2f),A
OUT ($2f),A
OUT ($2f),A
LD  A,xx
OUT ($2e),A
</pre>
<p>
Only at this last instruction the output appears.
</p>

<p>
If we substitute <code>$20</code> for <code>xx</code>, we get:
</p>
<pre>41h 41h 41h</pre>
<p>
and if we substitute <code>$22</code> for <code>xx</code>, we get:
</p>
<pre>065 065 065</pre>
<p>
The extra zero is added to keep alignment.  Finally, if we want ASCII
output, all we need to do is change <code>xx</code> for <code>$23</code>:
</p>
<pre>AAA</pre>
<p>
In this special case, the space in between the data is left out. Any special
character like carriage return, linefeed, beep or tab will be printed as can be
expected.
</p>

<h3><a id="debugdeviceoutput">8.5 Controlling the Output</a></h3>

<p>
The openMSX console can be used to control the output of the device. This is
done by the setting <code>debugoutput</code>. You can set it to any file name or to the special settings <code>stdout</code> and <code>stderr</code>, which lets the output go to these special streams.
</p>

<h2><a id="contact">9. Contact Info</a></h2>

<p>
Since openMSX is still in heavy development, feedback and bug reports are very
welcome!
</p>

<p>
If you encounter problems, you have several options:
</p>

<ol>
<li>
If you're a regular user and want to discuss openMSX and possible problems,
join our <code>openmsx-user</code> mailing list.
More info on the
<a class="external" href="http://sourceforge.net/mail/?group_id=38274">openMSX mailing lists</a>,
including an archive of old messages, can be found at SourceForge.
</li>
<li>
Go to our IRC channel: <code>#openMSX</code> on <code>irc.freenode.net</code>
and ask your question there.
</li>
<li>
If you want to address the openMSX developers directly,
post a message to the <code>openmsx-devel</code> mailing list.
More info on the
<a class="external" href="http://sourceforge.net/mail/?group_id=38274">openMSX mailing lists</a>,
including an archive of old messages, can be found at SourceForge.
</li>
<li>
Use one of the
<a class="external" href="http://sourceforge.net/tracker/?group_id=38274">openMSX trackers</a>
at SourceForge.
At the moment of writing, there are four trackers:
Bugs, Support Requests, Patches and Feature Requests.
</li>
<li>
Post a message on the <a class="external" href="http://sourceforge.net/forum/?group_id=38274">openMSX forums</a> at SourceForge.
</li>
</ol>

<p>
In any case, try to give as much information as possible when you describe your
bug or request.
</p>

<p class="version">
$Id$
</p>

</body>
</html>
